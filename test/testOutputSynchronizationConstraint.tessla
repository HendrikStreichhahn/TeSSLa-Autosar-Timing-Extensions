include "../main/t2uOutputSynchronizationConstraint.tessla"
#include "../main/t2uHelpFunctions.tessla"

in stimulus: Events[Int]
in response1: Events[Int]
in response2: Events[Int]
in response3: Events[Int]

def tolerance = 5

def responseStreamCount = 3


#def test = outputSynchronizationConstraint3(stimulus, response1, response2, response3, tolerance) 
#def test = outputSynchronizationConstraint2(stimulus, response1, response2, tolerance) 

#out test

def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
            time(response3))))

    def eventStreamIndices = 
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(stimulus)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, stimulus), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(response1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, response1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, response2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, response3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])


def addNewCluster(storedClusters: Map[Int, outputSynchronizationCluster], newColor: Int, time: Int, responseStreamCount: Int): 
            Map[Int, outputSynchronizationCluster] :=
        Map.add(storedClusters, newColor, buildOutputSynchronizationCluster(time, responseStreamCount))
    
    #removes every entry of listToRemove from the given set
    liftable def removeListFromSet[A](aSet: Set[A], listToRemove: List[A]): Set[A]:=
        if (List.size(listToRemove) == 0) then
            aSet
        else
            removeListFromSet(
                if (Set.contains(aSet, List.head(listToRemove))) then 
                    Set.remove(aSet, List.head(listToRemove))
                else
                    aSet,
                List.tail(listToRemove))
    
    # build list from aMap with all keys given in remainingKeys
    liftable def mapValuesToList[A, B](aMap: Map[A, B], remainingKeys: List[A]): List[B]:=
        if List.size(remainingKeys) == 0 then
            List.empty[B]
        else
            List.append(mapValuesToList(aMap, List.tail(remainingKeys)),
                Map.get(aMap, List.head(remainingKeys)))
    
    # removes map entries with key = 0
    liftable def removeStimulusEvents(events: Map[Int, Int]): Map[Int, Int] :=
        if (Map.contains(events, 0)) then
            Map.remove(events, 0)
        else
            events
            
    def updateSynchronizationClusters(storedClusters: Map[Int, outputSynchronizationCluster], events: Map[Int, Int],
            unmatchedStimulusColors: Set[Int], timeNow: Int, responseStreamCount: Int): Map[Int, outputSynchronizationCluster] := {
        # set the given stream in cluster to true
        def setStreamInSynchronizationCluster(cluster: outputSynchronizationCluster, stream: Int): outputSynchronizationCluster = {
                startTime = cluster.startTime,
                fulfilledStreams = Map.add(cluster.fulfilledStreams, stream, true)
            }
        
        if Map.size(events) == 0 then
            storedClusters
        else
            updateSynchronizationClusters(
                # set stream to fulfilled in Cluster
                if (Map.contains(storedClusters, Map_headValue(events)) || Set.contains(unmatchedStimulusColors, Map_headValue(events))) then
                    Map.add(storedClusters, Map_headValue(events),
                        setStreamInSynchronizationCluster(
                            Map.get(
                                # add new cluster, if needed
                                if ((!Map.contains(storedClusters, Map_headValue(events))) && Set.contains(unmatchedStimulusColors, Map_headValue(events))) then
                                    addNewCluster(storedClusters, Map_headValue(events), timeNow, responseStreamCount)
                                else
                                    storedClusters,
                                Map_headValue(events)),
                            Map_headKey(events)))
                    else
                        storedClusters,
                Map_tail(events), unmatchedStimulusColors, timeNow, responseStreamCount)
        }
    
    # check, if all streams are fulfilled in this cluster. Ignores timing
    def clusterFulfilled(fulfilledStreams: Map[Int, Bool]): Bool :=
        if (Map.size(fulfilledStreams) == 0) then
            true
        else
            if (Map_headValue(fulfilledStreams)) then
                clusterFulfilled(Map_tail(fulfilledStreams))
            else
                false

    # searches for all fulfilled clusters in Map and returns their colors in a list
    #   storedClusters: Map with stored clusters (color -> cluster)
    liftable def fulfilledClustersInMapRec(storedClusters: Map[Int, outputSynchronizationCluster], aList: List[Int]): List[Int] :=
        if (Map.size(storedClusters) == 0) then
            aList
        else
            fulfilledClustersInMapRec(Map_tail(storedClusters), 
                if (clusterFulfilled(Map_headValue(storedClusters).fulfilledStreams)) then
                    List.append(aList, Map_headKey(storedClusters))
                else
                    aList)

    # searches for all fulfilled clusters in Map and returns their colors in a list
    #   storedClusters: Map with stored clusters (color -> cluster)
    liftable def fulfilledClustersInMap(storedClusters: Map[Int, outputSynchronizationCluster]): List[Int] :=
        fulfilledClustersInMapRec(storedClusters, List.empty[Int])
    
    #removes clusters from Map
    def removeClusters(storedClusters: Map[Int, outputSynchronizationCluster], colorsToRemove: List[Int]): 
            Map[Int, outputSynchronizationCluster] :=
        if (List.size(colorsToRemove) == 0) then
            storedClusters
        else
            removeClusters(Map.remove(storedClusters, List.head(colorsToRemove)), List.tail(colorsToRemove))
    
    # all clusters younger than tolerance or fullfilled
    def clusterFulfillable(storedClustersBeforeRemove: Map[Int, outputSynchronizationCluster], tolerance: Int, timeNow: Int):
            Bool :=
        if (Map.size(storedClustersBeforeRemove) == 0) then
            true
        else
            clusterFulfillable(Map_tail(storedClustersBeforeRemove), tolerance, timeNow) &&
                (clusterFulfilled(Map_headValue(storedClustersBeforeRemove).fulfilledStreams) ||
                Map_headValue(storedClustersBeforeRemove).startTime + tolerance >= timeNow)
                
    liftable def startTimeOldestCluster(storedClustersBeforeRemove: Map[Int, outputSynchronizationCluster]): Int :=
        if (Map.size(storedClustersBeforeRemove) == 0) then
            infty
        else
            min(Map_headValue(storedClustersBeforeRemove).startTime,
                startTimeOldestCluster(Map_tail(storedClustersBeforeRemove)))

    # Stored Information #
    def unmatchedStimulusColors: Events[Set[Int]] := merge(
            removeListFromSet(
                if (Map.contains(eventStreamIndices, 0)) then
                    Set.add(last(unmatchedStimulusColors, eventStreamIndices), Map.get(eventStreamIndices, 0))
                else
                    last(unmatchedStimulusColors, eventStreamIndices),
                mapValuesToList(removeStimulusEvents(eventStreamIndices), Map.keys(removeStimulusEvents(eventStreamIndices)))),
        Set.empty[Int])

    def storedClustersBeforeRemove : Events[Map[Int, outputSynchronizationCluster]] := 
        merge(slift5(last(storedClusters, time(eventStreamIndices)), removeStimulusEvents(eventStreamIndices), prev(unmatchedStimulusColors),
        time(eventStreamIndices), responseStreamCount, updateSynchronizationClusters),
        Map.empty[Int, outputSynchronizationCluster])
    
    # stored clusters after removing the clusters, which were fulfilled in this timestamp
    def storedClusters: Events[Map[Int, outputSynchronizationCluster]] := merge(
        slift(storedClustersBeforeRemove, slift1(storedClustersBeforeRemove, fulfilledClustersInMap), removeClusters),
        Map.empty[Int, outputSynchronizationCluster])
    
    # delay
    def evalTimes = time(mergeUnit(eventStreamIndices,
        safeDelay(slift1(storedClusters, startTimeOldestCluster) + tolerance - time(eventStreamIndices) + 1, eventStreamIndices)))
    
    #no unfinished synchronization clusters and no unmatched Stimulus colors
    def output := stillFulfillabe(if (Set.size(unmatchedStimulusColors) == 0 && Map.size(storedClusters) == 0) then
        {value= true, final= false}
    else
        # unfulfilled stimulus colors exist, all clusters are still fulfillable-> current false
        if startTimeOldestCluster(storedClusters) + tolerance > evalTimes then
            {value= false, final= false}
        else
            {value= false, final= true})
            
    #out output
    
    out storedClusters
