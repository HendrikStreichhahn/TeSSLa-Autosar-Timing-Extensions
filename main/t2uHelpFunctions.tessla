def infty : Int := 9223372036854775807

type fourValuedBoolean = {value: Bool, final: Bool}

liftable def fourValuedConjunction(a: fourValuedBoolean, b: fourValuedBoolean):=
    if ((!a.value && a.final) || (!b.value && b.final)) then
        {value= false, final= true}
    else
        if ((!a.value && !a.final) || (!b.value && !b.final)) then
            {value= false, final= false}
        else
            if ((a.value && !a.final) || (b.value && !b.final)) then
                {value= true, final= false}
            else
                {value= true, final= true}


# time of the event, or 0, if there wasn't an event before
def defaultTime[T](stream: Events[T]): Events[Int]:=
    default(time(stream), 0)
    
# smallest value in map
def mapMinimumValueRec(aMap: Map[Int, Int], keys: List[Int]) : Int :=
    if (List.size(keys) == 0) then
        infty
    else
        min(Map.get(aMap, List.head(keys)),
            mapMinimumValueRec(aMap, List.tail(keys)))

# smallest value in map
def mapMinimumValue(aMap: Map[Int, Int]) : Int :=
    mapMinimumValueRec(aMap, Map.keys(aMap))
    
# checks, if all values in Int->Bool map are true
def mapAllTrue(aMap: Map[Int, Bool]): Bool :=
    mapAllTrueRec(aMap, Map.keys(aMap))

# checks, if all values in int->bool map within the key list are true
def mapAllTrueRec(aMap: Map[Int, Bool], keys: List[Int]): Bool :=
    if (Map.size(aMap) == 0 || List.size(keys) == 0) then
        true
    else
        Map.get(aMap, List.head(keys)) && mapAllTrueRec(aMap, List.tail(keys))


# remove all elementsm that equal val, from the list
def List_remove(aList: List[Int], val: Int): List[Int] :=
    if (List.size(aList) == 0) then
        aList
    else
        if (List.head(aList) == val) then
            List_remove(List.tail(aList), val)
        else
            List.prepend(List.head(aList), List_remove(List.tail(aList), val));
        

# FREMDQUELLTEXT => abgewandelte Form von resetCount
def resetSum[A](events: Events[Int], reset: Events[A]): Events[Int] = sum where {
  def sum: Events[Int] = default(
    # `reset` contains the latest event
    if default(time(reset) > time(events), false) then
        0
    # `reset` and `events` latest event happen simultaneously
    else 
        if default(time(reset) == time(events), false) then
            events
        # `events` contains the latest event > increment counter
        else
            last(sum, events) + events,
    0)
}

# once {value= false, final= true}-> always {value= false, final= true}
def stillFulfillabe(events: Events[fourValuedBoolean]): Events[fourValuedBoolean] :={
    def storage: Events[Bool] := merge(
        last(storage, events) && events != {value= false, final= true},
        true)

    if storage then
        events
    else
        {value= false, final= true}
}

# builds a map with [1, init], [2, init], ..., [size, init]  
def buildMap[A](size: Int, init: A): Map[Int, A] :=
    if (size <= 0) then
        Map.empty[Int, A]
    else {
        def recBuildMap = buildMap(size-1, init)
        Map.add(recBuildMap, Map.size(recBuildMap)+1, init)
    }

# delay, but delay is infty, if delay value is negative
def safeDelay[T](delays: Events[Int], resets: Events[T]): Events[Unit] :=
    delay(if(delays > 0) then delays else infty, resets)
	
#removes all list elements, that are smaller than A from the list
# list must be in ascending order
def removeItemsSmallerThanAFromListFront(list: List[Int], A: Int): List[Int] :=
	if (List.size(list) == 0) then
		list
	else
		if List.head(list) < A then
			removeItemsSmallerThanAFromListFront(List.tail(list), A)
		else
			list
