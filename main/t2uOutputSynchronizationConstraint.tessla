include "t2uConstraints.tessla"

## nodoc
def buildOutputSynchronizationCluster(time: Int, streamCount: Int) : outputSynchronizationCluster =
    {startTime = time, fulfilledStreams = buildMap(streamCount, false)}
# State information for currently active snchronization clusters
#   startTime: startTime of the cluster (timestamp of first event in this cluster)
#   fulfilledStreams.key:   Indices of all streams
#   fulfilledStreams.value: event in this stream for this cluster?
## nodoc
type outputSynchronizationCluster = {startTime: Int, fulfilledStreams: Map[Int, Bool]}

## Checks the OutputSynchronizationConstraint defined in TADL2.
## In the OutputSynchronizationConstraint, there must be one synchronization cluster of the length tolerance for each stimulus event. Each response stream must have at least one event of the same color as the stimulus event in this cluster.
## A stream of maps must be created, representing the events of each timestamp. The key of each entry is the index of the stream (0 for the stimulus stream, 1, 2, ... for the response streams), in which the event occurred and the value is the color of the event.
## The creation of this map is already implemented for up to 10 response streams, see outputSynchronizationConstraint2, ... .
## The source code expects the colors of the streams to fulfill the correctness of event chain. See checkEventChain to check this.
##
## **Usage Example**
##
## ~~~tessla
## in stimulus: Events[Int]
## in response1: Events[Int]
## in response2: Events[Int]
## in response3: Events[Int]
##
## def constraint= outputSynchronizationConstraint3(stimulus, response1, response2, response3, 2)
## out constraint
##~~~
##
## **Trace Example**
##
## ~~~trace
## option timeDomain:[-1,20]
## 1: stimulus = 1
## 5: response1 = 1
## 5: response2 = 1
## 6: response3 = 1
## 11: stimulus = 2
## 12: stimulus = 3
## 15: response1= 2
## 15: response2= 3
## 15: response3= 2
## 16: response1= 3
## 16: response2= 2
## 16: response3= 3
## ~~~
def outputSynchronizationConstraint(eventStreamIndices: Events[Map[Int, Int]], responseStreamCount: Int, tolerance: Int): Events[fourValuedBoolean]:= {
    ##### Help funtions #####
    # add an empty cluster to storedClusters
    def addNewCluster(storedClusters: Map[Int, outputSynchronizationCluster], newColor: Int, time: Int, responseStreamCount: Int): 
            Map[Int, outputSynchronizationCluster] :=
        Map.add(storedClusters, newColor, buildOutputSynchronizationCluster(time, responseStreamCount))
    
    #removes every entry of listToRemove from the given set
    liftable def removeListFromSet[A](aSet: Set[A], listToRemove: List[A]): Set[A]:=
        if (List.size(listToRemove) == 0) then
            aSet
        else
            removeListFromSet(
                if (Set.contains(aSet, List.head(listToRemove))) then 
                    Set.remove(aSet, List.head(listToRemove))
                else
                    aSet,
                List.tail(listToRemove))
    
    # build list from aMap with all keys given in remainingKeys
    liftable def mapValuesToList[A, B](aMap: Map[A, B], remainingKeys: List[A]): List[B]:=
        if List.size(remainingKeys) == 0 then
            List.empty[B]
        else
            List.append(mapValuesToList(aMap, List.tail(remainingKeys)),
                Map.get(aMap, List.head(remainingKeys)))
    
    # removes map entries with key = 0
    liftable def removeStimulusEvents(events: Map[Int, Int]): Map[Int, Int] :=
        if (Map.contains(events, 0)) then
            Map.remove(events, 0)
        else
            events
    #updates the stored synchronization clusters by all events in this timestamp (update or creation of new cluster)
    def updateSynchronizationClusters(storedClusters: Map[Int, outputSynchronizationCluster], events: Map[Int, Int], eventKeys: List[Int],
            unmatchedStimulusColors: Set[Int], timeNow: Int): Map[Int, outputSynchronizationCluster] := {
        # set the given stream in cluster to true
        def setStreamInSynchronizationCluster(cluster: outputSynchronizationCluster, stream: Int): outputSynchronizationCluster = {
                startTime = cluster.startTime,
                fulfilledStreams = Map.add(cluster.fulfilledStreams, stream, true)
            }
        
        if List.size(eventKeys) == 0 then
            storedClusters
        else
            updateSynchronizationClusters(
                # set stream to fulfilled in Cluster
                if (Map.contains(storedClusters, Map.get(events, List.head(eventKeys))) || Set.contains(unmatchedStimulusColors, Map.get(events, List.head(eventKeys)))) then
                    Map.add(storedClusters, Map.get(events, List.head(eventKeys)),
                        setStreamInSynchronizationCluster(
                            Map.get(
                                # add new cluster, if needed
                                if ((!Map.contains(storedClusters, Map.get(events, List.head(eventKeys)))) && Set.contains(unmatchedStimulusColors, Map.get(events, List.head(eventKeys)))) then
                                    addNewCluster(storedClusters, Map.get(events, List.head(eventKeys)), timeNow, responseStreamCount)
                                else
                                    storedClusters,
                                Map.get(events, List.head(eventKeys))),
                            List.head(eventKeys)))
                    else
                        storedClusters,
                events, List.tail(eventKeys), unmatchedStimulusColors, timeNow)
        }
    
    # check, if all streams are fulfilled in this cluster. Ignores timing
    def clusterFulfilled(fulfilledStreams: Map[Int, Bool], keys: List[Int]): Bool :=
        if (List.size(keys) == 0) then
            true
        else
            if (Map.get(fulfilledStreams,  List.head(keys))) then
                clusterFulfilled(fulfilledStreams, List.tail(keys))
            else
                false

    # searches for all fulfilled clusters in Map and returns their colors in a list
    #   storedClusters: Map with stored clusters (color -> cluster)
    liftable def fulfilledClustersInMapRec(storedClusters: Map[Int, outputSynchronizationCluster], aList: List[Int], keys: List[Int]): List[Int] :=
        if (List.size(keys) == 0) then
            aList
        else
            fulfilledClustersInMapRec(storedClusters, 
                if (clusterFulfilled(Map.get(storedClusters, List.head(keys)).fulfilledStreams, Map.keys(Map.get(storedClusters, List.head(keys)).fulfilledStreams))) then
                    List.append(aList, List.head(keys))
                else
                    aList, List.tail(keys))

    # searches for all fulfilled clusters in Map and returns their colors in a list
    #   storedClusters: Map with stored clusters (color -> cluster)
    liftable def fulfilledClustersInMap(storedClusters: Map[Int, outputSynchronizationCluster]): List[Int] :=
        fulfilledClustersInMapRec(storedClusters, List.empty[Int], Map.keys(storedClusters))
    
    #removes clusters from Map
    def removeClusters(storedClusters: Map[Int, outputSynchronizationCluster], colorsToRemove: List[Int]): 
            Map[Int, outputSynchronizationCluster] :=
        if (List.size(colorsToRemove) == 0) then
            storedClusters
        else
            removeClusters(Map.remove(storedClusters, List.head(colorsToRemove)), List.tail(colorsToRemove))
                
    liftable def startTimeOldestCluster(storedClustersBeforeRemove: Map[Int, outputSynchronizationCluster],
            keys: List[Int]): Int :=
        if (List.size(keys) == 0) then
            infty
        else
            min(Map.get(storedClustersBeforeRemove, List.head(keys)).startTime,
                startTimeOldestCluster(storedClustersBeforeRemove, List.tail(keys)))

    # Stored Information #
    
    #stimulus colors without matching target event
    def unmatchedStimulusColors: Events[Set[Int]] := merge(
            removeListFromSet(
                if (Map.contains(eventStreamIndices, 0)) then
                    Set.add(last(unmatchedStimulusColors, eventStreamIndices), Map.get(eventStreamIndices, 0))
                else
                    last(unmatchedStimulusColors, eventStreamIndices),
                mapValuesToList(removeStimulusEvents(eventStreamIndices), Map.keys(removeStimulusEvents(eventStreamIndices)))),
        Set.empty[Int])

    # synchronization clusters with new stimulus events
    def storedClustersBeforeRemove : Events[Map[Int, outputSynchronizationCluster]] := 
        merge(slift5(last(storedClusters, time(eventStreamIndices)), removeStimulusEvents(eventStreamIndices), Map.keys(removeStimulusEvents(eventStreamIndices)), prev(unmatchedStimulusColors),
        time(eventStreamIndices), updateSynchronizationClusters),
        Map.empty[Int, outputSynchronizationCluster])
    
    # stored clusters after removing the clusters, which were fulfilled in this timestamp
    def storedClusters: Events[Map[Int, outputSynchronizationCluster]] := merge(
        slift(storedClustersBeforeRemove, slift1(storedClustersBeforeRemove, fulfilledClustersInMap), removeClusters),
        Map.empty[Int, outputSynchronizationCluster])
    
    # timestamps, in which the evaluation occurs
    def evalTimes = time(mergeUnit(eventStreamIndices,
        safeDelay(slift(storedClusters, Map.keys(storedClusters), startTimeOldestCluster) + tolerance - time(eventStreamIndices) + 1, eventStreamIndices)))
    
    #no unfinished synchronization clusters and no unmatched Stimulus colors
    stillFulfillabe(if (Set.size(unmatchedStimulusColors) == 0 && Map.size(storedClusters) == 0) then
        {value= true, final= false}
    else
        # unfulfilled stimulus colors exist, all clusters are still fulfillable-> current false
        if startTimeOldestCluster(storedClusters, Map.keys(storedClusters)) + tolerance > evalTimes then
            {value= false, final= false}
        else
            {value= false, final= true})

}

## checks the OutputSynchronizationConstraint for two streams.
## See OutputSynchronizationConstraint for further information.
def outputSynchronizationConstraint2(stimulus: Events[Int], response1: Events[Int], response2: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        (time(response2))))

    def eventStimulus:= if (defaultTime(stimulus)  >= timeNow) then Map.add(Map.empty[Int, Int], 0, default(stimulus, -1)) else Map.empty[Int, Int]
    def eventResponse1:= if (defaultTime(response1)  >= timeNow) then Map.add(eventStimulus, 1, default(response1, -1)) else eventStimulus
    def eventResponse2:= if (defaultTime(response2)  >= timeNow) then Map.add(eventResponse1, 2, default(response2, -1)) else eventResponse1
    outputSynchronizationConstraint(eventResponse2, 2, tolerance)
}

## checks the OutputSynchronizationConstraint for three streams.
## See OutputSynchronizationConstraint for further information.
def outputSynchronizationConstraint3(stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
            time(response3))))

    def eventStimulus:= if (defaultTime(stimulus)  >= timeNow) then Map.add(Map.empty[Int, Int], 0, default(stimulus, -1)) else Map.empty[Int, Int]
    def eventResponse1:= if (defaultTime(response1)  >= timeNow) then Map.add(eventStimulus, 1, default(response1, -1)) else eventStimulus
    def eventResponse2:= if (defaultTime(response2)  >= timeNow) then Map.add(eventResponse1, 2, default(response2, -1)) else eventResponse1
    def eventResponse3:= if (defaultTime(response3)  >= timeNow) then Map.add(eventResponse2, 3, default(response3, -1)) else eventResponse2
    outputSynchronizationConstraint(eventResponse3, 3, tolerance)
}

## checks the OutputSynchronizationConstraint for four streams.
## See OutputSynchronizationConstraint for further information.
def outputSynchronizationConstraint4(stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], response4: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
        merge(time(response3),
            time(response4)))))
            
    def eventStimulus:= if (defaultTime(stimulus)  >= timeNow) then Map.add(Map.empty[Int, Int], 0, default(stimulus, -1)) else Map.empty[Int, Int]
    def eventResponse1:= if (defaultTime(response1)  >= timeNow) then Map.add(eventStimulus, 1, default(response1, -1)) else eventStimulus
    def eventResponse2:= if (defaultTime(response2)  >= timeNow) then Map.add(eventResponse1, 2, default(response2, -1)) else eventResponse1
    def eventResponse3:= if (defaultTime(response3)  >= timeNow) then Map.add(eventResponse2, 3, default(response3, -1)) else eventResponse2
    def eventResponse4:= if (defaultTime(response4)  >= timeNow) then Map.add(eventResponse3, 4, default(response4, -1)) else eventResponse3
    
    outputSynchronizationConstraint(eventResponse4, 4, tolerance)
}

## checks the OutputSynchronizationConstraint for five streams.
## See OutputSynchronizationConstraint for further information.
def outputSynchronizationConstraint5(stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], response4: Events[Int], response5: Events[Int], tolerance: Int):
        Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
        merge(time(response3),
        merge(time(response4),
            time(response5))))))

    def eventStimulus:= if (defaultTime(stimulus)  >= timeNow) then Map.add(Map.empty[Int, Int], 0, default(stimulus, -1)) else Map.empty[Int, Int]
    def eventResponse1:= if (defaultTime(response1)  >= timeNow) then Map.add(eventStimulus, 1, default(response1, -1)) else eventStimulus
    def eventResponse2:= if (defaultTime(response2)  >= timeNow) then Map.add(eventResponse1, 2, default(response2, -1)) else eventResponse1
    def eventResponse3:= if (defaultTime(response3)  >= timeNow) then Map.add(eventResponse2, 3, default(response3, -1)) else eventResponse2
    def eventResponse4:= if (defaultTime(response4)  >= timeNow) then Map.add(eventResponse3, 4, default(response4, -1)) else eventResponse3
    def eventResponse5:= if (defaultTime(response5)  >= timeNow) then Map.add(eventResponse4, 5, default(response5, -1)) else eventResponse4
    
    outputSynchronizationConstraint(eventResponse5, 5, tolerance)
}

## checks the OutputSynchronizationConstraint for six streams.
## See OutputSynchronizationConstraint for further information.
def outputSynchronizationConstraint6(stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], response4: Events[Int], response5: Events[Int], response6: Events[Int],
        tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
        merge(time(response3),
        merge(time(response4),
        merge(time(response5),
            time(response6)))))))

    def eventStimulus:= if (defaultTime(stimulus)  >= timeNow) then Map.add(Map.empty[Int, Int], 0, default(stimulus, -1)) else Map.empty[Int, Int]
    def eventResponse1:= if (defaultTime(response1)  >= timeNow) then Map.add(eventStimulus, 1, default(response1, -1)) else eventStimulus
    def eventResponse2:= if (defaultTime(response2)  >= timeNow) then Map.add(eventResponse1, 2, default(response2, -1)) else eventResponse1
    def eventResponse3:= if (defaultTime(response3)  >= timeNow) then Map.add(eventResponse2, 3, default(response3, -1)) else eventResponse2
    def eventResponse4:= if (defaultTime(response4)  >= timeNow) then Map.add(eventResponse3, 4, default(response4, -1)) else eventResponse3
    def eventResponse5:= if (defaultTime(response5)  >= timeNow) then Map.add(eventResponse4, 5, default(response5, -1)) else eventResponse4
    def eventResponse6:= if (defaultTime(response6)  >= timeNow) then Map.add(eventResponse5, 6, default(response6, -1)) else eventResponse5
    
    outputSynchronizationConstraint(eventResponse6, 6, tolerance)
}

## checks the OutputSynchronizationConstraint for seven streams.
## See OutputSynchronizationConstraint for further information.
def outputSynchronizationConstraint7(stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], response4: Events[Int], response5: Events[Int], response6: Events[Int],
        response7: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
        merge(time(response3),
        merge(time(response4),
        merge(time(response5),
        merge(time(response6),
            time(response7))))))))

    def eventStimulus:= if (defaultTime(stimulus)  >= timeNow) then Map.add(Map.empty[Int, Int], 0, default(stimulus, -1)) else Map.empty[Int, Int]
    def eventResponse1:= if (defaultTime(response1)  >= timeNow) then Map.add(eventStimulus, 1, default(response1, -1)) else eventStimulus
    def eventResponse2:= if (defaultTime(response2)  >= timeNow) then Map.add(eventResponse1, 2, default(response2, -1)) else eventResponse1
    def eventResponse3:= if (defaultTime(response3)  >= timeNow) then Map.add(eventResponse2, 3, default(response3, -1)) else eventResponse2
    def eventResponse4:= if (defaultTime(response4)  >= timeNow) then Map.add(eventResponse3, 4, default(response4, -1)) else eventResponse3
    def eventResponse5:= if (defaultTime(response5)  >= timeNow) then Map.add(eventResponse4, 5, default(response5, -1)) else eventResponse4
    def eventResponse6:= if (defaultTime(response6)  >= timeNow) then Map.add(eventResponse5, 6, default(response6, -1)) else eventResponse5
    def eventResponse7:= if (defaultTime(response7)  >= timeNow) then Map.add(eventResponse6, 7, default(response7, -1)) else eventResponse6
    
    outputSynchronizationConstraint(eventResponse7, 7, tolerance)
}

## checks the OutputSynchronizationConstraint for eight streams.
## See OutputSynchronizationConstraint for further information.
def outputSynchronizationConstraint8(stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], response4: Events[Int], response5: Events[Int], response6: Events[Int],
        response7: Events[Int], response8: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
        merge(time(response3),
        merge(time(response4),
        merge(time(response5),
        merge(time(response6),
        merge(time(response7),
            time(response8)))))))))

    def eventStimulus:= if (defaultTime(stimulus)  >= timeNow) then Map.add(Map.empty[Int, Int], 0, default(stimulus, -1)) else Map.empty[Int, Int]
    def eventResponse1:= if (defaultTime(response1)  >= timeNow) then Map.add(eventStimulus, 1, default(response1, -1)) else eventStimulus
    def eventResponse2:= if (defaultTime(response2)  >= timeNow) then Map.add(eventResponse1, 2, default(response2, -1)) else eventResponse1
    def eventResponse3:= if (defaultTime(response3)  >= timeNow) then Map.add(eventResponse2, 3, default(response3, -1)) else eventResponse2
    def eventResponse4:= if (defaultTime(response4)  >= timeNow) then Map.add(eventResponse3, 4, default(response4, -1)) else eventResponse3
    def eventResponse5:= if (defaultTime(response5)  >= timeNow) then Map.add(eventResponse4, 5, default(response5, -1)) else eventResponse4
    def eventResponse6:= if (defaultTime(response6)  >= timeNow) then Map.add(eventResponse5, 6, default(response6, -1)) else eventResponse5
    def eventResponse7:= if (defaultTime(response7)  >= timeNow) then Map.add(eventResponse6, 7, default(response7, -1)) else eventResponse6
    def eventResponse8:= if (defaultTime(response8)  >= timeNow) then Map.add(eventResponse7, 8, default(response8, -1)) else eventResponse7
    
    outputSynchronizationConstraint(eventResponse8, 8, tolerance)
}

## checks the OutputSynchronizationConstraint for nine streams.
## See OutputSynchronizationConstraint for further information.
def outputSynchronizationConstraint9(stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], response4: Events[Int], response5: Events[Int], response6: Events[Int],
        response7: Events[Int], response8: Events[Int], response9: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
        merge(time(response3),
        merge(time(response4),
        merge(time(response5),
        merge(time(response6),
        merge(time(response7),
        merge(time(response8),
            time(response9))))))))))

    def eventStimulus:= if (defaultTime(stimulus)  >= timeNow) then Map.add(Map.empty[Int, Int], 0, default(stimulus, -1)) else Map.empty[Int, Int]
    def eventResponse1:= if (defaultTime(response1)  >= timeNow) then Map.add(eventStimulus, 1, default(response1, -1)) else eventStimulus
    def eventResponse2:= if (defaultTime(response2)  >= timeNow) then Map.add(eventResponse1, 2, default(response2, -1)) else eventResponse1
    def eventResponse3:= if (defaultTime(response3)  >= timeNow) then Map.add(eventResponse2, 3, default(response3, -1)) else eventResponse2
    def eventResponse4:= if (defaultTime(response4)  >= timeNow) then Map.add(eventResponse3, 4, default(response4, -1)) else eventResponse3
    def eventResponse5:= if (defaultTime(response5)  >= timeNow) then Map.add(eventResponse4, 5, default(response5, -1)) else eventResponse4
    def eventResponse6:= if (defaultTime(response6)  >= timeNow) then Map.add(eventResponse5, 6, default(response6, -1)) else eventResponse5
    def eventResponse7:= if (defaultTime(response7)  >= timeNow) then Map.add(eventResponse6, 7, default(response7, -1)) else eventResponse6
    def eventResponse8:= if (defaultTime(response8)  >= timeNow) then Map.add(eventResponse7, 8, default(response8, -1)) else eventResponse7
    def eventResponse9:= if (defaultTime(response9)  >= timeNow) then Map.add(eventResponse8, 9, default(response9, -1)) else eventResponse8
    
    outputSynchronizationConstraint(eventResponse9, 9, tolerance)
}

## checks the OutputSynchronizationConstraint for ten streams.
## See OutputSynchronizationConstraint for further information.
def outputSynchronizationConstraint10(stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], response4: Events[Int], response5: Events[Int], response6: Events[Int],
        response7: Events[Int], response8: Events[Int], response9: Events[Int], response10: Events[Int],
        tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
        merge(time(response3),
        merge(time(response4),
        merge(time(response5),
        merge(time(response6),
        merge(time(response7),
        merge(time(response8),
        merge(time(response9),
            time(response10)))))))))))

    def eventStimulus:= if (defaultTime(stimulus)  >= timeNow) then Map.add(Map.empty[Int, Int], 0, default(stimulus, -1)) else Map.empty[Int, Int]
    def eventResponse1:= if (defaultTime(response1)  >= timeNow) then Map.add(eventStimulus, 1, default(response1, -1)) else eventStimulus
    def eventResponse2:= if (defaultTime(response2)  >= timeNow) then Map.add(eventResponse1, 2, default(response2, -1)) else eventResponse1
    def eventResponse3:= if (defaultTime(response3)  >= timeNow) then Map.add(eventResponse2, 3, default(response3, -1)) else eventResponse2
    def eventResponse4:= if (defaultTime(response4)  >= timeNow) then Map.add(eventResponse3, 4, default(response4, -1)) else eventResponse3
    def eventResponse5:= if (defaultTime(response5)  >= timeNow) then Map.add(eventResponse4, 5, default(response5, -1)) else eventResponse4
    def eventResponse6:= if (defaultTime(response6)  >= timeNow) then Map.add(eventResponse5, 6, default(response6, -1)) else eventResponse5
    def eventResponse7:= if (defaultTime(response7)  >= timeNow) then Map.add(eventResponse6, 7, default(response7, -1)) else eventResponse6
    def eventResponse8:= if (defaultTime(response8)  >= timeNow) then Map.add(eventResponse7, 8, default(response8, -1)) else eventResponse7
    def eventResponse9:= if (defaultTime(response9)  >= timeNow) then Map.add(eventResponse8, 9, default(response9, -1)) else eventResponse8
    def eventResponse10:= if (defaultTime(response10)  >= timeNow) then Map.add(eventResponse9, 10, default(response10, -1)) else eventResponse9
    
    outputSynchronizationConstraint(eventResponse10, 10, tolerance)
}
        