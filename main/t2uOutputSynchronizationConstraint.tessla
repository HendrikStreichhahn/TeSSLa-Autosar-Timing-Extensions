include "t2uConstraints.tessla"

def buildOutputSynchronizationCluster(time: Int, streamCount: Int) : outputSynchronizationCluster =
    {startTime = time, fulfilledStreams = buildMap(streamCount, false)}

type outputSynchronizationCluster = {startTime: Int, fulfilledStreams: Map[Int, Bool]}
def outputSynchronizationConstraint[A](eventStreamIndices: Events[Map[Int, Int]], responseStreamCount: Int, tolerance: Int,
        endOfStreams: Events[A]): Events[Bool]:= {
    ##### Help funtions #####

    # add an empty cluster to storedClusters
    def addNewCluster(storedClusters: Map[Int, outputSynchronizationCluster], newColor: Int, time: Int, responseStreamCount: Int): 
            Map[Int, outputSynchronizationCluster] :=
        Map_add(storedClusters, newColor, buildOutputSynchronizationCluster(time, responseStreamCount))

    # removes map entries with key = 0
    @liftable
    def removeStimulusEvents(events: Map[Int, Int]): Map[Int, Int] :=
        if (Map_contains(events, 0)) then
            Map_remove(events, 0)
        else
            events
    
    # updates given clusters by all given events
    # expects clusters to exist
    #   storedClusters: Map with stored clusters (color -> cluster)
    #   events: Map with all events in this timestamp (streamIndex -> color)
    #               streamIndex = 0    -> stimulus
    #               streamIndex = 1..n -> response
    def updateSynchronizationClusters(storedClusters: Map[Int, outputSynchronizationCluster], events: Map[Int, Int], 
            timeNow: Int, responseStreamCount: Int): Map[Int, outputSynchronizationCluster] := {
        # set the given stream in cluster to true
        def setStreamInSynchronizationCluster(cluster: outputSynchronizationCluster, stream: Int): outputSynchronizationCluster = {
                startTime = cluster.startTime,
                fulfilledStreams = Map_add(cluster.fulfilledStreams, stream, true)
            }
        
        static if Map_size(events) == 0 then
            storedClusters
        else
            updateSynchronizationClusters(
                # set stream to fulfilled in Cluster
                Map_add(storedClusters, Map_headValue(events),
                    setStreamInSynchronizationCluster(
                        Map_get(
                            # add new cluster, if needed
                            if (Map_contains(storedClusters, Map_headValue(events))) then
                                storedClusters
                            else
                                addNewCluster(storedClusters, Map_headValue(events), timeNow, responseStreamCount),
                            Map_headValue(events)),
                        Map_headKey(events))),
                Map_tail(events), timeNow, responseStreamCount)
        }
    
    # check, if all streams are fulfilled in this cluster. Ignores timing
    def clusterFulfilled(fulfilledStreams: Map[Int, Bool]): Bool :=
        static if (Map_size(fulfilledStreams) == 0) then
            true
        else
            static if (Map_headValue(fulfilledStreams)) then
                clusterFulfilled(Map_tail(fulfilledStreams))
            else
                false

    # searches for all fulfilled clusters in Map and returns their colors in a list
    #   storedClusters: Map with stored clusters (color -> cluster)
    def fulfilledClustersInMapRec(storedClusters: Map[Int, outputSynchronizationCluster], aList: List[Int]): List[Int] :=
        static if (Map_size(storedClusters) == 0) then
            aList
        else
            fulfilledClustersInMapRec(Map_tail(storedClusters), 
                static if (clusterFulfilled(Map_headValue(storedClusters).fulfilledStreams)) then
                    List_append(aList, Map_headKey(storedClusters))
                else
                    aList)

    # searches for all fulfilled clusters in Map and returns their colors in a list
    #   storedClusters: Map with stored clusters (color -> cluster)
    def fulfilledClustersInMap(storedClusters: Map[Int, outputSynchronizationCluster]): List[Int] :=
        fulfilledClustersInMapRec(storedClusters, List_empty[Int])

    #removes clusters from Map
    def removeClusters(storedClusters: Map[Int, outputSynchronizationCluster], colorsToRemove: List[Int]): 
            Map[Int, outputSynchronizationCluster] :=
        static if (List_size(colorsToRemove) == 0) then
            storedClusters
        else
            removeClusters(Map_remove(storedClusters, List_head(colorsToRemove)), List_tail(colorsToRemove))
    
    # all clusters younger than tolerance or fullfilled
    def constraintFulfilled(storedClustersBeforeRemove: Map[Int, outputSynchronizationCluster], tolerance: Int, timeNow: Int):
            Bool :=
        static if (Map_size(storedClustersBeforeRemove) == 0) then
            true
        else
            constraintFulfilled(Map_tail(storedClustersBeforeRemove), tolerance, timeNow) &&
                (clusterFulfilled(Map_headValue(storedClustersBeforeRemove).fulfilledStreams) ||
                Map_headValue(storedClustersBeforeRemove).startTime + tolerance >= timeNow)
    
    def startTimeOldestCluster(storedClustersBeforeRemove: Map[Int, outputSynchronizationCluster]): Int :=
        static if (Map_size(storedClustersBeforeRemove) == 0) then
            infty
        else
            min(Map_headValue(storedClustersBeforeRemove).startTime,
                startTimeOldestCluster(Map_tail(storedClustersBeforeRemove)))
                
    def addAllCurrentColorsToSet(eventStreamIndices: Map[Int, Int], colors: Set[Int], currentTime: Int): Set[Int] :=
        static if (Map_size(eventStreamIndices) == 0) then
            colors
        else
            addAllCurrentColorsToSet(Map_tail(eventStreamIndices),
                if !(Set_contains(colors, Map_headValue(eventStreamIndices)) || Map_headKey(eventStreamIndices) == 0) then
                    Set_add(colors, Map_headValue(eventStreamIndices))
                else
                    colors, 
                currentTime)
                
    def responseColorsWereInStimulus(eventStreamIndices: Map[Int, Int], stimulusColors: List[Int]): Bool:=
        static if (Map_size(eventStreamIndices) == 0) then
            true
        else
            List_containsInt(stimulusColors, Map_headValue(eventStreamIndices)) && 
            responseColorsWereInStimulus(Map_tail(eventStreamIndices), stimulusColors)
    
    # Stored Information #
    def stimulusColors: Events[List[Int]] := merge(
            if (Map_contains(eventStreamIndices, 0)) then
                List_append(last(stimulusColors, eventStreamIndices), Map_get(eventStreamIndices, 0))
            else
                last(stimulusColors, eventStreamIndices),
        List_empty[Int])
    
    # stored clusters without removing in this timestamp
    def storedClustersBeforeRemove : Events[Map[Int, outputSynchronizationCluster]] := 
        merge(slift4(last(storedClusters, time(eventStreamIndices)), removeStimulusEvents(eventStreamIndices), time(eventStreamIndices), responseStreamCount,
            updateSynchronizationClusters),
        Map_empty[Int, outputSynchronizationCluster])
    
    # stored clusters after removing the clusters, which were fulfilled in this timestamp
    def storedClusters: Events[Map[Int, outputSynchronizationCluster]] := merge(
        slift(storedClustersBeforeRemove, slift1(storedClustersBeforeRemove, fulfilledClustersInMap), removeClusters),
        Map_empty[Int, outputSynchronizationCluster])
        
    # colors of all fulfilled cluster
    def allFulfilled: Events[List[Int]] :=
        merge(List_attachIntLifted(last(allFulfilled, time(eventStreamIndices)), slift1(storedClustersBeforeRemove, fulfilledClustersInMap)), List_empty[Int])
    
    #each color, that previosly were in response
    #def previousResponseColors: Events[Set[Int]] := merge(
    #    slift3(eventStreamIndices, last(previousResponseColors, evalTimes), evalTimes, addAllCurrentColorsToSet),
    #    Set_empty[Int])

    # delay
    def evalTimes = time(mergeUnit(eventStreamIndices,
        delay(slift1(storedClusters, startTimeOldestCluster) + tolerance - time(eventStreamIndices) + 1, eventStreamIndices)))

    # Evaluation and output #
        # each started synchronization cluster is younger than tolerance or fulfilled
    allPreviousTrue(slift3(storedClustersBeforeRemove, tolerance, evalTimes, constraintFulfilled) &&
        # on end of streams-> all stimulus colors had synchronization cluster
        merge(on(endOfStreams,  slift(stimulusColors, allFulfilled, aSublistEqBInt)), true) &&
        #current response color were in stimulus before (no seperation between stimulus and response needed in function call-> stimulus results in true anyway)
        slift(eventStreamIndices, stimulusColors, responseColorsWereInStimulus))
}

def outputSynchronizationConstraint2[A](stimulus: Events[Int], response1: Events[Int], response2: Events[Int], tolerance: Int,
        endOfStreams: Events[A]): Events[Bool] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        (time(response2))))

    def eventsNow = 
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(stimulus)  >= timeNow) then merge(Map_add(Map_empty[Int, Int], 0, stimulus), Map_empty[Int, Int]) 
                                                   else Map_empty[Int, Int],
            if (defaultTime(response1) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 1, response1), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(response2) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 2, response2), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int])
    outputSynchronizationConstraint(eventsNow, 2, tolerance, endOfStreams)
}

def outputSynchronizationConstraint3[A](stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], tolerance: Int, endOfStreams: Events[A]): Events[Bool] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
            time(response3))))

    def eventsNow = 
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(stimulus)  >= timeNow) then merge(Map_add(Map_empty[Int, Int], 0, stimulus), Map_empty[Int, Int]) 
                                                   else Map_empty[Int, Int],
            if (defaultTime(response1) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 1, response1), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(response2) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 2, response2), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(response3) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 3, response3), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int])
    outputSynchronizationConstraint(eventsNow, 3, tolerance, endOfStreams)
}

def outputSynchronizationConstraint4[A](stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], response4: Events[Int], tolerance: Int, endOfStreams: Events[A]): Events[Bool] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
        merge(time(response3),
            time(response4)))))

    def eventsNow = 
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(stimulus)  >= timeNow) then merge(Map_add(Map_empty[Int, Int], 0, stimulus), Map_empty[Int, Int]) 
                                                   else Map_empty[Int, Int],
            if (defaultTime(response1) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 1, response1), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(response2) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 2, response2), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(response3) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 3, response3), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(response4) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 4, response4), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int])
    outputSynchronizationConstraint(eventsNow, 4, tolerance, endOfStreams)
}

def outputSynchronizationConstraint5[A](stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], response4: Events[Int], response5: Events[Int], tolerance: Int, endOfStreams: Events[A]):
        Events[Bool] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
        merge(time(response3),
        merge(time(response4),
            time(response5))))))

    def eventsNow = 
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(stimulus)  >= timeNow) then merge(Map_add(Map_empty[Int, Int], 0, stimulus), Map_empty[Int, Int]) 
                                                   else Map_empty[Int, Int],
            if (defaultTime(response1) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 1, response1), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(response2) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 2, response2), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(response3) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 3, response3), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(response4) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 4, response4), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(response5) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 5, response5), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int])
    outputSynchronizationConstraint(eventsNow, 5, tolerance, endOfStreams)
}
        