include "t2uConstraints.tessla"

def buildOutputSynchronizationCluster(time: Int, streamCount: Int) : outputSynchronizationCluster =
    {startTime = time, fulfilledStreams = buildMap(streamCount, false)}

type outputSynchronizationCluster = {startTime: Int, fulfilledStreams: Map[Int, Bool]}
def outputSynchronizationConstraint(eventStreamIndices: Events[Map[Int, Int]], responseStreamCount: Int, tolerance: Int): Events[fourValuedBoolean]:= {
    ##### Help funtions #####
    # add an empty cluster to storedClusters
    def addNewCluster(storedClusters: Map[Int, outputSynchronizationCluster], newColor: Int, time: Int, responseStreamCount: Int): 
            Map[Int, outputSynchronizationCluster] :=
        Map.add(storedClusters, newColor, buildOutputSynchronizationCluster(time, responseStreamCount))
    
    #removes every entry of listToRemove from the given set
    liftable def removeListFromSet[A](aSet: Set[A], listToRemove: List[A]): Set[A]:=
        if (List.size(listToRemove) == 0) then
            aSet
        else
            removeListFromSet(
                if (Set.contains(aSet, List.head(listToRemove))) then 
                    Set.remove(aSet, List.head(listToRemove))
                else
                    aSet,
                List.tail(listToRemove))
    
    # build list from aMap with all keys given in remainingKeys
    liftable def mapValuesToList[A, B](aMap: Map[A, B], remainingKeys: List[A]): List[B]:=
        if List.size(remainingKeys) == 0 then
            List.empty[B]
        else
            List.append(mapValuesToList(aMap, List.tail(remainingKeys)),
                Map.get(aMap, List.head(remainingKeys)))
    
    # removes map entries with key = 0
    liftable def removeStimulusEvents(events: Map[Int, Int]): Map[Int, Int] :=
        if (Map.contains(events, 0)) then
            Map.remove(events, 0)
        else
            events
            
    def updateSynchronizationClusters(storedClusters: Map[Int, outputSynchronizationCluster], events: Map[Int, Int],
            unmatchedStimulusColors: Set[Int], timeNow: Int, responseStreamCount: Int): Map[Int, outputSynchronizationCluster] := {
        # set the given stream in cluster to true
        def setStreamInSynchronizationCluster(cluster: outputSynchronizationCluster, stream: Int): outputSynchronizationCluster = {
                startTime = cluster.startTime,
                fulfilledStreams = Map.add(cluster.fulfilledStreams, stream, true)
            }
        
        if Map.size(events) == 0 then
            storedClusters
        else
            updateSynchronizationClusters(
                # set stream to fulfilled in Cluster
                if (Map.contains(storedClusters, Map_headValue(events)) || Set.contains(unmatchedStimulusColors, Map_headValue(events))) then
                    Map.add(storedClusters, Map_headValue(events),
                        setStreamInSynchronizationCluster(
                            Map.get(
                                # add new cluster, if needed
                                if ((!Map.contains(storedClusters, Map_headValue(events))) && Set.contains(unmatchedStimulusColors, Map_headValue(events))) then
                                    addNewCluster(storedClusters, Map_headValue(events), timeNow, responseStreamCount)
                                else
                                    storedClusters,
                                Map_headValue(events)),
                            Map_headKey(events)))
                    else
                        storedClusters,
                Map_tail(events), unmatchedStimulusColors, timeNow, responseStreamCount)
        }
    
    # check, if all streams are fulfilled in this cluster. Ignores timing
    def clusterFulfilled(fulfilledStreams: Map[Int, Bool]): Bool :=
        if (Map.size(fulfilledStreams) == 0) then
            true
        else
            if (Map_headValue(fulfilledStreams)) then
                clusterFulfilled(Map_tail(fulfilledStreams))
            else
                false

    # searches for all fulfilled clusters in Map and returns their colors in a list
    #   storedClusters: Map with stored clusters (color -> cluster)
    liftable def fulfilledClustersInMapRec(storedClusters: Map[Int, outputSynchronizationCluster], aList: List[Int]): List[Int] :=
        if (Map.size(storedClusters) == 0) then
            aList
        else
            fulfilledClustersInMapRec(Map_tail(storedClusters), 
                if (clusterFulfilled(Map_headValue(storedClusters).fulfilledStreams)) then
                    List.append(aList, Map_headKey(storedClusters))
                else
                    aList)

    # searches for all fulfilled clusters in Map and returns their colors in a list
    #   storedClusters: Map with stored clusters (color -> cluster)
    liftable def fulfilledClustersInMap(storedClusters: Map[Int, outputSynchronizationCluster]): List[Int] :=
        fulfilledClustersInMapRec(storedClusters, List.empty[Int])
    
    #removes clusters from Map
    def removeClusters(storedClusters: Map[Int, outputSynchronizationCluster], colorsToRemove: List[Int]): 
            Map[Int, outputSynchronizationCluster] :=
        if (List.size(colorsToRemove) == 0) then
            storedClusters
        else
            removeClusters(Map.remove(storedClusters, List.head(colorsToRemove)), List.tail(colorsToRemove))
    
    # all clusters younger than tolerance or fullfilled
    def clusterFulfillable(storedClustersBeforeRemove: Map[Int, outputSynchronizationCluster], tolerance: Int, timeNow: Int):
            Bool :=
        if (Map.size(storedClustersBeforeRemove) == 0) then
            true
        else
            clusterFulfillable(Map_tail(storedClustersBeforeRemove), tolerance, timeNow) &&
                (clusterFulfilled(Map_headValue(storedClustersBeforeRemove).fulfilledStreams) ||
                Map_headValue(storedClustersBeforeRemove).startTime + tolerance >= timeNow)
                
    liftable def startTimeOldestCluster(storedClustersBeforeRemove: Map[Int, outputSynchronizationCluster]): Int :=
        if (Map.size(storedClustersBeforeRemove) == 0) then
            infty
        else
            min(Map_headValue(storedClustersBeforeRemove).startTime,
                startTimeOldestCluster(Map_tail(storedClustersBeforeRemove)))

    # Stored Information #
    def unmatchedStimulusColors: Events[Set[Int]] := merge(
            removeListFromSet(
                if (Map.contains(eventStreamIndices, 0)) then
                    Set.add(last(unmatchedStimulusColors, eventStreamIndices), Map.get(eventStreamIndices, 0))
                else
                    last(unmatchedStimulusColors, eventStreamIndices),
                mapValuesToList(removeStimulusEvents(eventStreamIndices), Map.keys(removeStimulusEvents(eventStreamIndices)))),
        Set.empty[Int])

    def storedClustersBeforeRemove : Events[Map[Int, outputSynchronizationCluster]] := 
        merge(slift5(last(storedClusters, time(eventStreamIndices)), removeStimulusEvents(eventStreamIndices), prev(unmatchedStimulusColors),
        time(eventStreamIndices), responseStreamCount, updateSynchronizationClusters),
        Map.empty[Int, outputSynchronizationCluster])
    
    # stored clusters after removing the clusters, which were fulfilled in this timestamp
    def storedClusters: Events[Map[Int, outputSynchronizationCluster]] := merge(
        slift(storedClustersBeforeRemove, slift1(storedClustersBeforeRemove, fulfilledClustersInMap), removeClusters),
        Map.empty[Int, outputSynchronizationCluster])
    
    # delay
    def evalTimes = time(mergeUnit(eventStreamIndices,
        safeDelay(slift1(storedClusters, startTimeOldestCluster) + tolerance - time(eventStreamIndices) + 1, eventStreamIndices)))
    
    #no unfinished synchronization clusters and no unmatched Stimulus colors
    stillFulfillabe(if (Set.size(unmatchedStimulusColors) == 0 && Map.size(storedClusters) == 0) then
        {value= true, final= false}
    else
        # unfulfilled stimulus colors exist, all clusters are still fulfillable-> current false
        if startTimeOldestCluster(storedClusters) + tolerance > evalTimes then
            {value= false, final= false}
        else
            {value= false, final= true})

}

def outputSynchronizationConstraint2(stimulus: Events[Int], response1: Events[Int], response2: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        (time(response2))))

    def eventsNow = 
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(stimulus)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, stimulus), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(response1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, response1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, response2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    outputSynchronizationConstraint(eventsNow, 2, tolerance)
}

def outputSynchronizationConstraint3(stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
            time(response3))))

    def eventsNow = 
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(stimulus)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, stimulus), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(response1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, response1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, response2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, response3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    outputSynchronizationConstraint(eventsNow, 3, tolerance)
}

def outputSynchronizationConstraint4(stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], response4: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
        merge(time(response3),
            time(response4)))))

    def eventsNow = 
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(stimulus)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, stimulus), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(response1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, response1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, response2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, response3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response4) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 4, response4), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    outputSynchronizationConstraint(eventsNow, 4, tolerance)
}

def outputSynchronizationConstraint5(stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], response4: Events[Int], response5: Events[Int], tolerance: Int):
        Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
        merge(time(response3),
        merge(time(response4),
            time(response5))))))

    def eventsNow = 
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(stimulus)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, stimulus), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(response1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, response1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, response2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, response3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response4) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 4, response4), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response5) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 5, response5), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    outputSynchronizationConstraint(eventsNow, 5, tolerance)
}

def outputSynchronizationConstraint6(stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], response4: Events[Int], response5: Events[Int], response6: Events[Int],
        tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
        merge(time(response3),
        merge(time(response4),
        merge(time(response5),
            time(response6)))))))

    def eventsNow = 
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(stimulus)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, stimulus), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(response1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, response1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, response2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, response3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response4) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 4, response4), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response5) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 5, response5), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response6) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 6, response6), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    outputSynchronizationConstraint(eventsNow, 6, tolerance)
}

def outputSynchronizationConstraint7(stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], response4: Events[Int], response5: Events[Int], response6: Events[Int],
        response7: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
        merge(time(response3),
        merge(time(response4),
        merge(time(response5),
        merge(time(response6),
            time(response7))))))))

    def eventsNow = 
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(stimulus)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, stimulus), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(response1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, response1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, response2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, response3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response4) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 4, response4), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response5) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 5, response5), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response6) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 6, response6), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response7) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 7, response7), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    outputSynchronizationConstraint(eventsNow, 7, tolerance)
}

def outputSynchronizationConstraint8(stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], response4: Events[Int], response5: Events[Int], response6: Events[Int],
        response7: Events[Int], response8: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
        merge(time(response3),
        merge(time(response4),
        merge(time(response5),
        merge(time(response6),
        merge(time(response7),
            time(response8)))))))))

    def eventsNow = 
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(stimulus)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, stimulus), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(response1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, response1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, response2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, response3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response4) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 4, response4), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response5) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 5, response5), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response6) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 6, response6), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response7) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 7, response7), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response8) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 8, response8), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    outputSynchronizationConstraint(eventsNow, 8, tolerance)
}

def outputSynchronizationConstraint9(stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], response4: Events[Int], response5: Events[Int], response6: Events[Int],
        response7: Events[Int], response8: Events[Int], response9: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
        merge(time(response3),
        merge(time(response4),
        merge(time(response5),
        merge(time(response6),
        merge(time(response7),
        merge(time(response8),
            time(response9))))))))))

    def eventsNow = 
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(stimulus)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, stimulus), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(response1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, response1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, response2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, response3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response4) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 4, response4), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response5) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 5, response5), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response6) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 6, response6), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response7) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 7, response7), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response8) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 8, response8), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response9) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 9, response9), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    outputSynchronizationConstraint(eventsNow, 9, tolerance)
}

def outputSynchronizationConstraint10(stimulus: Events[Int], response1: Events[Int], response2: Events[Int],
        response3: Events[Int], response4: Events[Int], response5: Events[Int], response6: Events[Int],
        response7: Events[Int], response8: Events[Int], response9: Events[Int], response10: Events[Int],
        tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus),
        merge(time(response1),
        merge(time(response2),
        merge(time(response3),
        merge(time(response4),
        merge(time(response5),
        merge(time(response6),
        merge(time(response7),
        merge(time(response8),
        merge(time(response9),
            time(response10)))))))))))

    def eventsNow = 
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(stimulus)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, stimulus), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(response1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, response1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, response2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, response3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response4) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 4, response4), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response5) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 5, response5), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response6) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 6, response6), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response7) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 7, response7), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response8) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 8, response8), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response9) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 9, response9), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(response10) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 10, response10), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    outputSynchronizationConstraint(eventsNow, 10, tolerance)
}
        