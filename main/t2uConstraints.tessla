include "t2uHelpFunctions.tessla"

def delayConstraint[A, B](source: Events[A], target: Events[B], lower: Int, upper: Int) :={
    def unfinishedSourceTimesNewSource: Events[List[Int]] := 
        # 'now' has source event
        if (defaultTime(source) >= defaultTime(target)) then
            merge(List_append(last(unfinishedSourceTimes, mergeUnit(source, target)), time(source)),
                  List_empty[Int])
        else
            merge(last(unfinishedSourceTimes, mergeUnit(source, target)), List_empty[Int])
    #
    def unfinishedSourceTimes: Events[List[Int]]:=
        # 'now' has target event
        if (defaultTime(source) <= defaultTime(target) &&
                # List has source event without matching target
                List_size(unfinishedSourceTimesNewSource) > 0 &&
                # target event now matches with oldest source event
                List_head(unfinishedSourceTimesNewSource) + lower <= defaultTime(target) &&
                List_head(unfinishedSourceTimesNewSource) + upper >= defaultTime(target)) then
            #remove matched target events
            merge(slift(unfinishedSourceTimesNewSource, defaultTime(target), 
					removeItemsSmallerThanAFromListFront),
				List_empty[Int])
        else
            merge(unfinishedSourceTimesNewSource, List_empty[Int])
      
	def evaluateTimes = mergeUnit(mergeUnit(source, target),
        safeDelay(if (List_size(unfinishedSourceTimes) == 0) then
				infty
			else
				List_head(unfinishedSourceTimes) + upper - time(mergeUnit(source, target))+1, 
			mergeUnit(source, target)))

    # no unfinished source events
    (List_size(unfinishedSourceTimes) == 0) ||
    # oldest source event can still be finished
    time(evaluateTimes) <= List_head(unfinishedSourceTimes) + upper
}

def strongDelayConstraint[A, B](source: Events[A], target: Events[B], lower: Int, upper: Int) :={
    #List with times of events on source without matching (until now) target event
    def unfinishedSourceTimes: Events[List[Int]] :=
        #event now is source event
        if (defaultTime(source) > defaultTime(target)) then
            merge(List_append(last(unfinishedSourceTimes, mergeUnit(source, target)), time(source)),
                  List_empty[Int])
        else if (defaultTime(source) < defaultTime(target)) then
            merge(List_tail(last(unfinishedSourceTimes, mergeUnit(source, target))), List_empty[Int])
        else # defaultTime(source) == defaultTime(target)
            merge(List_append(List_tail(last(unfinishedSourceTimes, mergeUnit(source, target))), time(source)),
                  List_empty[Int])
    # delay
    def evaluateTimes = mergeUnit(mergeUnit(source, target),
        safeDelay(if (List_size(unfinishedSourceTimes) == 0) then
				infty
			else
				List_head(unfinishedSourceTimes) + upper - time(mergeUnit(source, target))+1, 
			mergeUnit(source, target)))
	# output
    allPreviousTrue(
        # Event now is source-event
        if (defaultTime(source) > defaultTime(target)) then
            #head of list is in valid distance or head is empty
            (List_size(last(unfinishedSourceTimes, evaluateTimes)) == 0) ||
            time(evaluateTimes) <= List_head(last(unfinishedSourceTimes, evaluateTimes)) + upper
        # Event now is target event or events on both streams
        else
            # List is not empty
            List_size(last(unfinishedSourceTimes, evaluateTimes)) > 0 &&
            # Event now is target-event and fulfills constraint times
            defaultTime(target) >= List_head(last(unfinishedSourceTimes, evaluateTimes)) + lower &&
            defaultTime(target) <= List_head(last(unfinishedSourceTimes, evaluateTimes)) + upper)
}

def repeatConstraint[A](e: Events[A], lower: Int, upper: Int, span: Int): Events[Bool] := {
	#stored state
	def latestSpanEventTimes := nLastTime(e, span)
	def latestSpanButOneEventTimes := nLastTime(e, span-1)
	# delay
    def evaluateTimes = mergeUnit(e, 
            safeDelay((merge(latestSpanButOneEventTimes, firstEvent(time(e)))+ upper) - time(e)+1,e))

    allPreviousTrue(on(evaluateTimes,
		merge(default((lower <= (time(evaluateTimes) - latestSpanEventTimes) &&
                        time(evaluateTimes) - latestSpanEventTimes <= upper),
				true),
			firstEvent(time(e)) + upper > time(evaluateTimes))))
}
        
def repetitionConstraint[A](e: Events[A], lower: Int, upper: Int, span: Int, jitter: Int): Events[Bool] := {
    # lower bound for current x
    def lowerBoundXNow: Events[Int] =
        if (List_size(last(LowerBoundX, e)) < span) then
            time(e)-jitter
        else
            max(List_head(last(LowerBoundX, e)), time(e)-jitter)
    # upper bound for current x
    def upperBoundXNow: Events[Int] =
        if (List_size(last(LowerBoundX, e)) < span) then
            time(e)
        else
            min(List_head(last(UpperBoundX, e)), time(e))

    # lower bound for span next x
    def LowerBoundX: Events[List[Int]]:= merge(
        if (List_size(last(LowerBoundX, e)) < span) then
           List_append(last(LowerBoundX, e), lowerBoundXNow + lower)
        else
            List_append(last(List_tail(LowerBoundX), e), lowerBoundXNow + lower),
        List_empty[Int]
    )
        
     # upper bound for span next x
    def UpperBoundX: Events[List[Int]]:= merge(
        if (List_size(last(UpperBoundX, e)) < span) then
            List_append(last(UpperBoundX, e), upperBoundXNow+upper)
        else
            List_append(last(List_tail(UpperBoundX), e), upperBoundXNow + upper),
        List_empty[Int]
    )
    def evaluateTimes = mergeUnit(e, safeDelay(List_head(UpperBoundX) + jitter - time(e)+1, e))
    # Evaluation
    allPreviousTrue((List_size(LowerBoundX) == 0 && List_size(UpperBoundX) == 0) ||
        lowerBoundXNow <= time(evaluateTimes) &&
        upperBoundXNow + jitter >= time(evaluateTimes))
}

def executionTimeConstraint[A, B, C, D](start: Events[A], end: Events[B], preempt: Events[C], resume: Events[D],
        lower: Int, upper: Int): Events[Bool] :={
    # timestamps, when the constraint is evaluated
    def inputTimes: Events[Unit] := mergeUnit(mergeUnit(mergeUnit(start, end), preempt), resume)
    def evaluateTimes: Events[Unit] := 
        mergeUnit(inputTimes, safeDelay(if (time(inputTimes) != defaultTime(end)) then
                                            upper - execTime + 1
                                        else
                                            infty, inputTimes))

    # evaluation
    def execTime : Events[Int] := runtime(start, evaluateTimes) - resetSum(runtime(preempt, resume), start)
    # 'now' is end event
    allPreviousTrue(if (time(evaluateTimes) == defaultTime(end)) then
        lower <= execTime && execTime <= upper
    else
        #ignore lower
        execTime <= upper)
}

def orderConstraint[A, B, C](source: Events[A], target: Events[B], finite: Events[C]): Events[Bool] :=
    # if end of streams
    if (defaultTime(finite) >= defaultTime(source) && defaultTime(finite) >= defaultTime(target)) then
        count(source) == count(target)
    else
        count(source) >= count(target)

def sporadicConstraint[A](e: Events[A], lower: Int, upper: Int, jitter: Int, minDist: Int): Events[Bool]:=
    repetitionConstraint(e, lower, upper, 1, jitter) && repeatConstraint(e, minDist, infty, 1)

def periodicConstraint[A](events: Events[A], period: Int, jitter: Int, minDist: Int): Events[Bool] :=
    sporadicConstraint(events, period, period, jitter, minDist)

def arbitraryConstraintRec[A](e: Events[A], minDist: List[Int], maxDist: List[Int], ctr: Int): Events[Bool] :=
    static if (List_size(minDist) > 1 && List_size(maxDist) > 1) then
        arbitraryConstraintRec(e, List_tail(minDist), List_tail(maxDist), ctr+1) &&
        repeatConstraint(e, List_head(minDist), List_head(maxDist), ctr)
    else
        repeatConstraint(e, List_head(minDist), List_head(maxDist), ctr)

def arbitraryConstraint[A](e: Events[A], minDist: List[Int], maxDist: List[Int]): Events[Bool] :=
    arbitraryConstraintRec(e, minDist, maxDist, 1)

def burstConstraint(e: Events[Int], length: Int, maxOccurences: Int, minDist: Int): Events[Bool] :=
    repeatConstraint(e, length, infty, maxOccurences) && repeatConstraint(e, minDist, infty, 1)

def patternConstraint[A](e: Events[A], periodX: Int, offset: Map[Int, Int], jitter: Int, minimum: Int) : Events[Bool] := {
    # upper bound for latest e
    def lowerBoundX: Events[Int] :=  merge (
        # increase by period and adjust by offset and jitter
        if (count(e) % Map_size(offset) == 1 && !isFirst(e)) then
            max(last(lowerBoundX, e) + periodX,
                time(e) - Map_get(offset, (count(e)-1) % Map_size(offset))-jitter) 
        #adjust by offset and jitter
        else
            max(last(lowerBoundX, e),
                time(e) - Map_get(offset, (count(e)-1) % Map_size(offset))-jitter),
        time(e) - Map_get(offset, (count(e)-1) % Map_size(offset)) - jitter)
        
    def upperBoundX: Events[Int] :=  merge (
        # increase by period and adjust by offset and jitter
        if (count(e) % Map_size(offset) == 1 && !isFirst(e)) then
            min(last(upperBoundX, e) + periodX,
                time(e) - Map_get(offset, (count(e)-1) % Map_size(offset))) 
        else
        # adjust by offset and jitter
            min(last(upperBoundX, e),
                time(e) - Map_get(offset, (count(e)-1) % Map_size(offset))),
        time(e) - Map_get(offset, (count(e)-1) % Map_size(offset)))
    def evaluateTimes = mergeUnit(e, safeDelay(upperBoundX + 
        Map_get(offset, (count(e)) % Map_size(offset)) + jitter - time(e) + 1, e))
    #evaluate
    lowerBoundX + Map_get(offset, (count(e)-1) % Map_size(offset)) <= time(evaluateTimes) &&
        time(evaluateTimes) <= upperBoundX + Map_get(offset, (count(e)-1) % Map_size(offset)) + jitter &&
        repeatConstraint(e, minimum, infty, 1)
}

# subset reaction constraint without stray response events
def reactionConstraint(stimulus: Events[Int], response: Events[Int], minTimeDiff: Int, maxTimeDiff: Int): Events[Bool] := {
    # Map with unmatched stimulus events after stimulus
    def unmatchedStimulusEventsNewStimulus : Events[Map[Int, Int]]:= merge(
        if defaultTime(stimulus) >= defaultTime(response) &&
                !Map_contains(last(unmatchedStimulusEvents, merge(stimulus, response)), stimulus) then
            Map_add(last(unmatchedStimulusEvents, merge(stimulus, response)), stimulus, defaultTime(stimulus))
        else
            last(unmatchedStimulusEvents, merge(stimulus, response)),
        Map_empty[Int, Int])
    # Map with unmatched stimulus events after response
    def unmatchedStimulusEvents := merge (
        if (defaultTime(stimulus) <= defaultTime(response) &&
                Map_contains(unmatchedStimulusEventsNewStimulus, merge(response, -1)) &&
                Map_get(unmatchedStimulusEventsNewStimulus, merge(response, -1)) + minTimeDiff <= defaultTime(response) &&
                Map_get(unmatchedStimulusEventsNewStimulus, merge(response, -1)) + maxTimeDiff >= defaultTime(response)) then
            Map_remove(unmatchedStimulusEventsNewStimulus, response)
        else
            unmatchedStimulusEventsNewStimulus,
        unmatchedStimulusEventsNewStimulus)
    #set with color, that were previosly in response
    def previousResponseColors: Events[Set[Int]] := merge(
        # 'now' has response event
        if defaultTime(stimulus) <= defaultTime(response) then
            Set_add(last(previousResponseColors, merge(stimulus, response)), response)
        else
            last(previousResponseColors, merge(stimulus, response)),
        Set_empty[Int])
    
    def evaluateTimes = mergeUnit(mergeUnit(stimulus, response),
            safeDelay(slift1(unmatchedStimulusEvents, mapMinimumValue) + maxTimeDiff -
                time(mergeUnit(stimulus, response)) + 1,
                mergeUnit(stimulus, response)))
    #evaluation
    slift1(unmatchedStimulusEvents, mapMinimumValue) + maxTimeDiff >= time(evaluateTimes) &&
        # all unmatched stimulus events can still be matched
        # no stimulus with color, that was already in response
        ((!(defaultTime(stimulus) >= defaultTime(response))) ||
            !(Set_contains(previousResponseColors, stimulus)))
}

def ageConstraint(stimulus: Events[Int], response: Events[Int], minTimeDiff: Int, maxTimeDiff: Int): Events[Bool] := {
    # map with unmatched stimulus events after stimulus
    def unmatchedStimulusEventsNewStimulus : Events[Map[Int, Int]] := merge(
            if (defaultTime(stimulus) >= defaultTime(response)) then
                Map_add(last(unmatchedStimulusEvents, merge(stimulus, response)), stimulus, time(stimulus))
            else
                last(unmatchedStimulusEvents, merge(stimulus, response)),
        Map_empty[Int, Int])
        


    
    #def unmatchedStimulusEvents:= #unmatchedStimulusEventsNewStimulus
     #   slift(unmatchedStimulusEventsNewStimulus, time(merge(stimulus, response) - maxTimeDiff),
     #       removeEntrysValueSmallerThanAFromMap)
     # map with unmatched stimulus events after response
    def unmatchedStimulusEvents : Events[Map[Int, Int]]= merge(
        if (defaultTime(stimulus) <= defaultTime(response) &&
                Map_contains(unmatchedStimulusEventsNewStimulus, merge(response, -1)) &&
                Map_get(unmatchedStimulusEventsNewStimulus, merge(response, -1)) + minTimeDiff <= defaultTime(response) &&
                Map_get(unmatchedStimulusEventsNewStimulus, merge(response, -1)) + maxTimeDiff >= defaultTime(response)) then
            Map_remove(unmatchedStimulusEventsNewStimulus, response)
        else
            unmatchedStimulusEventsNewStimulus,
        unmatchedStimulusEventsNewStimulus)
    # set with colors that are no longer allowed on stimulus stream
    def invalidStimulusColors : Events[Set[Int]] := merge(
        if (defaultTime(stimulus) <= defaultTime(response)) then
            Set_add(last(invalidStimulusColors, merge(stimulus, response)), response)
        else
            last(invalidStimulusColors, merge(stimulus, response)),
        Set_empty[Int]
    )
    #evaluation
    # 'now' has stimulus event => color of stimulus event is valid
    ((!(defaultTime(stimulus) >= defaultTime(response))) ||
        !Set_contains(invalidStimulusColors, stimulus)) &&
    # 'now' has response event => time matches to unmatched stimulus event
    ((!(defaultTime(stimulus) <= defaultTime(response))) || 
        Map_contains(unmatchedStimulusEventsNewStimulus, merge(response, -1)) &&
        Map_get(unmatchedStimulusEventsNewStimulus, merge(response, -1)) + minTimeDiff <= defaultTime(response) &&
        Map_get(unmatchedStimulusEventsNewStimulus, merge(response, -1)) + maxTimeDiff >= defaultTime(response))
}
