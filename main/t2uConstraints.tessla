include "t2uHelpFunctions.tessla"

def delayConstraint[A, B](source: Events[A], target: Events[B], lower: Int, upper: Int) : Events[fourValuedBoolean] :={
    def unfinishedSourceTimesNewSource: Events[List[Int]] := 
        # 'now' has source event
        if (defaultTime(source) >= defaultTime(target)) then
            merge(List.append(last(unfinishedSourceTimes, mergeUnit(source, target)), time(source)),
                  List.empty[Int])
        else
            merge(last(unfinishedSourceTimes, mergeUnit(source, target)), List.empty[Int])
    #
    def unfinishedSourceTimes: Events[List[Int]]:=
        # 'now' has target event
        if (defaultTime(source) <= defaultTime(target) &&
                # List has source event without matching target
                List.size(unfinishedSourceTimesNewSource) > 0 &&
                # target event now matches with oldest source event
                List.head(unfinishedSourceTimesNewSource) + lower <= defaultTime(target) &&
                List.head(unfinishedSourceTimesNewSource) + upper >= defaultTime(target)) then
            #remove matched target events
            merge(slift(unfinishedSourceTimesNewSource, defaultTime(target) - lower + 1, 
					removeItemsSmallerThanAFromListFront),
				List.empty[Int])
        else
            merge(unfinishedSourceTimesNewSource, List.empty[Int])
      
	def evaluateTimes = mergeUnit(mergeUnit(source, target),
        safeDelay(if (List.size(unfinishedSourceTimes) == 0) then
				infty
			else
				List.head(unfinishedSourceTimes) + upper - time(mergeUnit(source, target))+1, 
			mergeUnit(source, target)))
            
    stillFulfillabe(
        # no unfinished source events -> current true
        if (List.size(unfinishedSourceTimes) == 0) then
            {value= true, final= false}
        else
            # oldest source event can still be finished-> current false
            if (time(evaluateTimes) <= List.head(unfinishedSourceTimes) + upper) then
                {value= false, final= false}
            # oldest source event is too old -> final false
            else
                {value= false, final= true})
}

def strongDelayConstraint[A, B](source: Events[A], target: Events[B], lower: Int, upper: Int) :={
    #List with times of events on source without matching (until now) target event
    def unfinishedSourceTimes: Events[List[Int]] :=
        #event now is source event
        if (defaultTime(source) > defaultTime(target)) then
            merge(List.append(last(unfinishedSourceTimes, mergeUnit(source, target)), time(source)),
                  List.empty[Int])
        else if (defaultTime(source) < defaultTime(target)) then
            merge(List.tail(last(unfinishedSourceTimes, mergeUnit(source, target))), List.empty[Int])
        else # defaultTime(source) == defaultTime(target)
            merge(List.append(List.tail(last(unfinishedSourceTimes, mergeUnit(source, target))), time(source)),
                  List.empty[Int])
    # delay
    def evaluateTimes = mergeUnit(mergeUnit(source, target),
        safeDelay(if (List.size(unfinishedSourceTimes) == 0) then#
				infty
			else
				List.head(unfinishedSourceTimes) + upper - time(mergeUnit(source, target))+1, 
			mergeUnit(source, target)))
	# output
    stillFulfillabe(
        # no unmatched source event-> current true
        if (List.size(last(unfinishedSourceTimes, evaluateTimes)) == 0) then
            {value= true, final= false}
        else
            # now just source events
            if (defaultTime(source) > defaultTime(target)) then
                # oldest stored event not too old
                if (time(evaluateTimes) <= List.head(last(unfinishedSourceTimes, evaluateTimes)) + upper) then
                    {value= false, final= false}
                else
                    {value= false, final= true}
            else
                # oldest stored event in right distance
                if (time(evaluateTimes) <= List.head(last(unfinishedSourceTimes, evaluateTimes)) + upper &&
                        defaultTime(target) >= List.head(last(unfinishedSourceTimes, evaluateTimes)) + lower ) then
                    {value= false, final= false}
                else
                    {value= false, final= true})
}

def repeatConstraint[A](e: Events[A], lower: Int, upper: Int, span: Int): Events[fourValuedBoolean] := {

    #stored state
    def latestSpanEventTimes: Events[List[Int]]:=
        merge(List.append(
            if (List.size(last(latestSpanEventTimes, e)) > span) then
                List.tail(last(latestSpanEventTimes, defaultTime(e)))
            else
                last(latestSpanEventTimes, e), defaultTime(e)),
            List.empty[Int])
    
    # delay
    def delayPeriod :=
        if (defaultTime(e) == defaultTime(firstEvent(e))) then
            List.head(latestSpanEventTimes) + upper - time(e) + 1
        else
            List.head(List.tail(latestSpanEventTimes)) + upper - time(e) + 1
    
    def evaluateTimes := 
        mergeUnit(e, safeDelay(delayPeriod, e))
    
    stillFulfillabe(
        # more than span events occured-> distance to span-1^th event is relevant
        if (List.size(latestSpanEventTimes) > span) then
            if List.head(latestSpanEventTimes) + lower <= time(evaluateTimes) &&
                    List.head(latestSpanEventTimes) + upper >= time(evaluateTimes) then
                {value= true, final= false}
            else
                {value= false, final= true}
        else
            # less than span events occurred-> first event must be younger than upper
            if List.head(latestSpanEventTimes) + upper >= time(evaluateTimes) then
                {value= true, final= false}
            else
                {value= false, final= true})
    
}
        
def repetitionConstraint[A](e: Events[A], lower: Int, upper: Int, span: Int, jitter: Int): Events[fourValuedBoolean] := {
    # lower bound for current x
    def lowerBoundXNow: Events[Int] =
        if (List.size(last(LowerBoundX, e)) < span) then
            time(e)-jitter
        else
            max(List.head(last(LowerBoundX, e)), time(e)-jitter)
    # upper bound for current x
    def upperBoundXNow: Events[Int] =
        if (List.size(last(UpperBoundX, e)) < span) then
            time(e)
        else
            min(List.head(last(UpperBoundX, e)), time(e))

    # lower bound for span next x
    def LowerBoundX: Events[List[Int]]:= merge(
        if (List.size(last(LowerBoundX, e)) < span) then
           List.append(last(LowerBoundX, e), lowerBoundXNow + lower)
        else
            List.append(last(List.tail(LowerBoundX), e), lowerBoundXNow + lower),
        List.empty[Int]
    )
        
     # upper bound for span next x
    def UpperBoundX: Events[List[Int]]:= merge(
        if (List.size(last(UpperBoundX, e)) < span) then
            List.append(last(UpperBoundX, e), upperBoundXNow+upper)
        else
            List.append(last(List.tail(UpperBoundX), e), upperBoundXNow + upper),
        List.empty[Int]
    )
    def evaluateTimes = mergeUnit(e,
        safeDelay((if (List.size(UpperBoundX) == 0) then 0 else List.head(UpperBoundX)) +
                jitter - time(e)+1, e))
    # Evaluation        
    stillFulfillabe(
        #first event or correct distance to X
        if (List.size(LowerBoundX) == 0 && List.size(UpperBoundX) == 0) ||
                lowerBoundXNow <= time(evaluateTimes) &&
                upperBoundXNow + jitter >= time(evaluateTimes) then
            {value= true, final= false}
        else
            {value= false, final= true})
}

def executionTimeConstraint[A, B, C, D](start: Events[A], end: Events[B], preempt: Events[C], resume: Events[D],
        lower: Int, upper: Int): Events[fourValuedBoolean] :={
    # timestamps, when the constraint is evaluated
    def inputTimes: Events[Unit] := mergeUnit(mergeUnit(mergeUnit(start, end), preempt), resume)
    def evaluateTimes: Events[Unit] := 
        mergeUnit(inputTimes, safeDelay(if (time(inputTimes) != defaultTime(end) &&
                                                time(inputTimes) != defaultTime(preempt)) then
                                            upper - execTime + 1
                                        else
                                            infty, inputTimes))

    # evaluation
    def execTime : Events[Int] := runtime(start, evaluateTimes) - resetSum(runtime(preempt, resume), start)
    # 'now' is end event
    #allPreviousTrue(if (time(evaluateTimes) == defaultTime(end)) then
    #    lower <= execTime && execTime <= upper
    #else
        #ignore lower
    #    execTime <= upper)
        
    stillFulfillabe(
        #first event or correct distance to X
        if (if (time(evaluateTimes) == defaultTime(end)) then
                lower <= execTime && execTime <= upper
            else
                #ignore lower
                execTime <= upper) then
            {value= true, final= false}
        else
            {value= false, final= true})
}

def orderConstraint[A, B](source: Events[A], target: Events[B]): Events[fourValuedBoolean] :=
    stillFulfillabe(
        if count(source) == count(target) then
            {value= true, final= false}
        else
            if (count(source) >= count(target)) then
                {value= false, final= false}
            else
                {value= false, final= true})

def sporadicConstraint[A](e: Events[A], lower: Int, upper: Int, jitter: Int, minDist: Int): Events[fourValuedBoolean]:=
    slift(repetitionConstraint(e, lower, upper, 1, jitter), repeatConstraint(e, minDist, infty, 1), fourValuedConjunction)

def periodicConstraint[A](events: Events[A], period: Int, jitter: Int, minDist: Int) :=
    sporadicConstraint(events, period, period, jitter, minDist)

def arbitraryConstraintRec[A](e: Events[A], minDist: List[Int], maxDist: List[Int], ctr: Int): Events[fourValuedBoolean] :=
    static if (List.size(minDist) > 1 && List.size(maxDist) > 1) then
        slift(arbitraryConstraintRec(e, List.tail(minDist), List.tail(maxDist), ctr+1),
            repeatConstraint(e, List.head(minDist), List.head(maxDist), ctr),
            fourValuedConjunction)
    else
        repeatConstraint(e, List.head(minDist), List.head(maxDist), ctr)

def arbitraryConstraint[A](e: Events[A], minDist: List[Int], maxDist: List[Int]): Events[fourValuedBoolean] :=
    arbitraryConstraintRec(e, minDist, maxDist, 1)

def burstConstraint[A](e: Events[A], length: Int, maxOccurences: Int, minDist: Int): Events[fourValuedBoolean] :=
    slift(repeatConstraint(e, length, infty, maxOccurences), repeatConstraint(e, minDist, infty, 1),
        fourValuedConjunction)

def patternConstraint[A](e: Events[A], periodX: Int, offset: Map[Int, Int], jitter: Int, minDist: Int) : Events[fourValuedBoolean] := {
    liftable def aModuloBOr1if1(a: Int, b: Int): Int:=
        if b == 1 then 1 else a % b;
    # upper bound for latest e
    def lowerBoundX: Events[Int] :=  merge (
        # increase by period and adjust by offset and jitter
        if (aModuloBOr1if1(count(e), Map.size(offset))== 1 && !isFirst(e)) then
            max(last(lowerBoundX, e) + periodX,
                time(e) - Map.get(offset, (count(e)-1) % Map.size(offset))-jitter) 
        #adjust by offset and jitter
        else
            max(last(lowerBoundX, e),
                time(e) - Map.get(offset, (count(e)-1) % Map.size(offset))-jitter),
        time(e) - Map.get(offset, (count(e)-1) % Map.size(offset)) - jitter)
        
    def upperBoundX: Events[Int] :=  merge (
        # increase by period and adjust by offset and jitter
        if (aModuloBOr1if1(count(e), Map.size(offset))== 1 && !isFirst(e))  then
            min(last(upperBoundX, e) + periodX,
                time(e) - Map.get(offset, (count(e)-1) % Map.size(offset))) 
        else
        # adjust by offset and jitter
            min(last(upperBoundX, e),
                time(e) - Map.get(offset, (count(e)-1) % Map.size(offset))),
        time(e) - Map.get(offset, (count(e)-1) % Map.size(offset)))
    def evaluateTimes= mergeUnit(e, safeDelay(upperBoundX + (if count(e) % Map.size(offset) == 0 then periodX else 0) +
        Map.get(offset, count(e) % Map.size(offset)) + jitter - time(e) + 1, e))
    #evaluate
    slift(if (lowerBoundX + Map.get(offset, (count(e)-1) % Map.size(offset)) <= time(evaluateTimes) &&
                time(evaluateTimes) <= upperBoundX + Map.get(offset, (count(e)-1) % Map.size(offset)) + jitter) then
            {value= true, final= false}
        else
            {value= false, final= true},
        repeatConstraint(e, minDist, infty, 1),
        fourValuedConjunction)
}

# subset reaction constraint without stray response events
def reactionConstraint(stimulus: Events[Int], response: Events[Int], minTimeDiff: Int, maxTimeDiff: Int): Events[fourValuedBoolean] := {
    # Map with unmatched stimulus events after stimulus
    def unmatchedStimulusEventsNewStimulus : Events[Map[Int, Int]]:= merge(
        if defaultTime(stimulus) >= defaultTime(response) &&
                !Map.contains(last(unmatchedStimulusEvents, merge(stimulus, response)), stimulus) then
            Map.add(last(unmatchedStimulusEvents, merge(stimulus, response)), stimulus, defaultTime(stimulus))
        else
            last(unmatchedStimulusEvents, merge(stimulus, response)),
        Map.empty[Int, Int])
    # Map with unmatched stimulus events after response
    def unmatchedStimulusEvents := merge (
        if (defaultTime(stimulus) <= defaultTime(response) &&
                Map.contains(unmatchedStimulusEventsNewStimulus, merge(response, -1)) &&
                Map.get(unmatchedStimulusEventsNewStimulus, merge(response, -1)) + minTimeDiff <= defaultTime(response) &&
                Map.get(unmatchedStimulusEventsNewStimulus, merge(response, -1)) + maxTimeDiff >= defaultTime(response)) then
            Map.remove(unmatchedStimulusEventsNewStimulus, response)
        else
            unmatchedStimulusEventsNewStimulus,
        unmatchedStimulusEventsNewStimulus)
    
    def evaluateTimes = mergeUnit(mergeUnit(stimulus, response),
            safeDelay(slift1(unmatchedStimulusEvents, mapMinimumValue) + maxTimeDiff -
                time(mergeUnit(stimulus, response)) + 1,
                mergeUnit(stimulus, response)))
                
    #evaluation
    # all unmatched stimulus events can still be matched
    stillFulfillabe(if (Map.size(unmatchedStimulusEvents) == 0) then
        {value= true, final= false}
    else
        if (slift1(unmatchedStimulusEvents, mapMinimumValue) + maxTimeDiff >= time(evaluateTimes)) then
            {value= false, final= false}
        else
            {value= false, final= true})
}


def ageConstraint(stimulus: Events[Int], response: Events[Int], minTimeDiff: Int, maxTimeDiff: Int): Events[fourValuedBoolean] := {
    #removes colors, that were before timeBound, from the list
    def removeOldStimulusColorsFromList(latestStimulusColors: List[Int],
            colorTimeStamps: Map[Int, Int], timeBound: Int): List[Int] :=
        # list empty
        if (List.size(latestStimulusColors) == 0) then
            latestStimulusColors
        else
            # oldest event not too old-> return current list
            if (Map.contains(colorTimeStamps, List.head(latestStimulusColors)) &&
                    Map.get(colorTimeStamps, List.head(latestStimulusColors)) >= timeBound) then
                latestStimulusColors
            else
                # recursive call without oldest color
                removeOldStimulusColorsFromList(List.tail(latestStimulusColors), colorTimeStamps, timeBound)
    
    #removes colors, that were before timeBound, from the map
    def removeOldStimulusColorsFromSet(latestStimulusColors: List[Int],
            colorTimeStamps: Map[Int, Int], timeBound: Int): Map[Int, Int] :=
        if (List.size(latestStimulusColors) == 0) then
            colorTimeStamps
        else
             # oldest event not too old-> return current map
            if (Map.contains(colorTimeStamps, List.head(latestStimulusColors)) &&
                    Map.get(colorTimeStamps, List.head(latestStimulusColors)) >= timeBound)  then
                colorTimeStamps
            else
                # recursive call without oldest color
                removeOldStimulusColorsFromSet(List.tail(latestStimulusColors),
                    Map.remove(colorTimeStamps, List.head(latestStimulusColors)), timeBound)


    # map with unmatched stimulus events after stimulus
    def stimulusEventsNewStimulus : Events[Map[Int, Int]] := 
            if (defaultTime(stimulus) >= defaultTime(response)) then
                Map.add(last(stimulusEvents, merge(stimulus, response)), stimulus, time(stimulus))
            else
                last(stimulusEvents, merge(stimulus, response))
    #remove events that are too old
    def stimulusEvents:=
        merge(
            slift3(last(stimulusColorsYoungerThanMax, stimulus),
                stimulusEventsNewStimulus,
                time(merge(stimulus, response)) - maxTimeDiff,
                removeOldStimulusColorsFromSet),
        Map.empty[Int, Int])
    
    def stimulusColorsYoungerThanMax: Events[List[Int]]:= merge(
        slift3(List.append(slift(last(stimulusColorsYoungerThanMax, stimulus), stimulus, List_remove), stimulus), 
            stimulusEvents, 
            time(merge(stimulus, response)) - maxTimeDiff,
            removeOldStimulusColorsFromList),
        List.empty[Int])
        
    #evaluation
    # 'now' has response event => time matches to unmatched stimulus event
    stillFulfillabe(
        if ((!(defaultTime(stimulus) <= defaultTime(response))) || 
            Map.contains(stimulusEventsNewStimulus, merge(response, -1)) &&
            Map.get(stimulusEventsNewStimulus, merge(response, -1)) + minTimeDiff <= defaultTime(response) &&
            Map.get(stimulusEventsNewStimulus, merge(response, -1)) + maxTimeDiff >= defaultTime(response)) then
        {value= true, final= false}
        else
            {value= false, final= true})
}

def checkEventChain(stimulus: Events[Int], response: Events[Int]): Events[fourValuedBoolean]:= {
    # colors, that occured in response-> not allows in stimulus anymore
    def previousResponseColors: Events[Set[Int]]:=
        merge(Set.add(last(previousResponseColors, response), response), Set.empty[Int])
    stillFulfillabe(
        if on(merge(stimulus, response),
            # stimulus event-> color didn't occur in response earlier
                if (defaultTime(stimulus) >= defaultTime(response)) then 
                    !Set.contains(previousResponseColors, stimulus)
                else
                    true) then
            {value= true, final= false}
        else
            {value= false, final= true})
}