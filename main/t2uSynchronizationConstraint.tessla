include "t2uHelpFunctions.tessla"

# state information for each event:
#   streamIndex: index of the stream, in which the event occurred
#   eventTime: timestamp of the event
#   fulfilled: found a synchronization cluster for this event?
type SynchronizationEventInfo = {streamIndex: Int, eventTime: Int, fulfilled: Bool}

def synchronizationConstraint(eventIndices: Events[List[Int]], streamCount: Int, tolerance: Int): Events[fourValuedBoolean]:= {

    def buildSynchronizationEventInfo(streamInd: Int, evtTime: Int, flflld: Bool) : SynchronizationEventInfo:=
        {streamIndex= streamInd, eventTime= evtTime, fulfilled= flflld}

    # add events from one timestamp to the state
    def addEvents(existingEvents: List[SynchronizationEventInfo], newEventStreamIndices: List[Int], timeNow: Int) :
            List[SynchronizationEventInfo]:=
        if (List.size(newEventStreamIndices) == 0) then
            existingEvents
        else
            addEvents(List.append(existingEvents,
                    buildSynchronizationEventInfo(List.head(newEventStreamIndices), timeNow, false)),
                List.tail(newEventStreamIndices), timeNow)
        
    # checks, if the events between timeNow and (timeNow-tolerance) fulfills the cluster
    def clusterFulfilled(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int, streamCount: Int): Bool :=
        mapAllTrue(fillIndecesList(events, timeNow, tolerance, buildMap(streamCount, false)))


    def fillIndecesList(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int,
            indicesList: Map[Int, Bool]): Map[Int, Bool] :=
        # no more events to check-> return indiceslist
        if (List.size(events) == 0) then
            indicesList
        else
            # recursive call with tail of events and updated indicesList
            fillIndecesList(List.tail(events), timeNow, tolerance,
                # time of event fits-> set to true
                if (List.head(events).eventTime + tolerance >= timeNow) then
                    Map.add(indicesList, List.head(events).streamIndex, true)
                else
                    indicesList)

    # sets all Events in list to fulfilled, if not too old
    def setEventsToFulfilled(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int, streamCount: Int): 
            List[SynchronizationEventInfo] :=
        if (List.size(events) == 0) then
            events
        else
            # set List.head to fulfilled, if not too old
            List.prepend(
                if (List.head(events).eventTime + tolerance >= timeNow) then
                    buildSynchronizationEventInfo(List.head(events).streamIndex, List.head(events).eventTime, true)
                else
                    List.head(events),
                setEventsToFulfilled(List.tail(events), timeNow, tolerance, streamCount))

    #set fulfilled state of events to true, if fulfilled
    def updateFullfilledEvents(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int, streamCount: Int):
            List[SynchronizationEventInfo]:=
        if (clusterFulfilled(events, timeNow, tolerance, streamCount)) then
            setEventsToFulfilled(events, timeNow, tolerance, streamCount)
        else
            events

    # creates a List with all events, that are older than tolerance
    def eventsToRemove(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int):
            List[SynchronizationEventInfo] :=
        if (List.size(events) == 0) then
            events
        else
            # head of List too old
            if(timeNow - List.head(events).eventTime > tolerance) then
                # add head of list to return list
                #List.prepend(List.head(events), eventsToRemove(List.tail(events), timeNow, tolerance))
                List.append(eventsToRemove(List.tail(events), timeNow, tolerance), List.head(events))
            else
                # rest of list can't be older-> return empty
                List.empty[SynchronizationEventInfo]

    # removes all events, that are older than tolerance
    def removeEvents(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int):
            List[SynchronizationEventInfo] :=
        if (List.size(events) == 0) then
            events
        else
            # head of List too old
            if(timeNow - List.head(events).eventTime > tolerance) then
                removeEvents(List.tail(events), timeNow, tolerance)
            else
                # rest of list can't be older-> return unchanged
                events

    def noUnfulfilledRemoved(removedEvents: List[SynchronizationEventInfo]) : Bool :=
        if (List.size(removedEvents) == 0) then
            true
        else
            List.head(removedEvents).fulfilled &&
            noUnfulfilledRemoved(List.tail(removedEvents))
    # insert new events and set cluster to fulfilled, if possible
   def storedEventsBeforeRemove: Events[List[SynchronizationEventInfo]] :=
        slift4(slift3(last(storedEvents, eventIndices), eventIndices, time(eventIndices), addEvents),
                time(eventIndices), tolerance, streamCount, updateFullfilledEvents)
    # remove old events from list
    def storedEvents: Events[List[SynchronizationEventInfo]] := merge(
        slift3(storedEventsBeforeRemove, time(eventIndices), tolerance, removeEvents),
        List.empty[SynchronizationEventInfo])
		
	def timeOldestUnfulfilledEvent(storedEvents: List[SynchronizationEventInfo]): Int :=
		if (List.size(storedEvents) == 0) then
			infty
		else
            if !List.head(storedEvents).fulfilled then
                List.head(storedEvents).eventTime
            else
                timeOldestUnfulfilledEvent(List.tail(storedEvents))
	
    # timestamps, in which the evaluation occurs
	def evaluateTimes = mergeUnit(eventIndices,
        safeDelay(slift1(storedEvents, timeOldestUnfulfilledEvent) + tolerance - time(eventIndices)+1, eventIndices))
        
    #Evaluation
    #no unfullfilled event-> current true
    stillFulfillabe(
        if (slift1(storedEvents, timeOldestUnfulfilledEvent) == infty) then
            {value= true, final= false}
        else
            #check, if all removed events are fulfilled(had a cluster)-> current false, but not final
            #if (slift1(slift3(storedEventsBeforeRemove, time(evaluateTimes), tolerance, eventsToRemove), noUnfulfilledRemoved)) then
            if (slift1(storedEventsBeforeRemove, timeOldestUnfulfilledEvent) >= time(evaluateTimes) - tolerance) then
                {value= false, final= false}
            else
                {value= false, final= true})
}

def synchronizationConstraint2[A, B](events1: Events[A], events2: Events[B], tolerance: Int):
        Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(events1, events2))
    
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, List.empty[Int])
        else
            List.empty[Int]
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    synchronizationConstraint(eventList, 2, tolerance)
}

def synchronizationConstraint3[A, B, C](events1: Events[A], events2: Events[B], events3: Events[C], tolerance: Int):
        Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(events1, events2), events3))
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, List.empty[Int])
        else
            List.empty[Int]
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    synchronizationConstraint(eventList, 3, tolerance)
}

def synchronizationConstraint4[A, B, C, D](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(events1, events2), events3), events4))
    
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, List.empty[Int])
        else
            List.empty[Int]
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    synchronizationConstraint(eventList, 4, tolerance)
}

def synchronizationConstraint5[A, B, C, D, E](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5))
     
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, List.empty[Int])
        else
            List.empty[Int]
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    synchronizationConstraint(eventList, 5, tolerance)
}

def synchronizationConstraint6[A, B, C, D, E, F](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6))
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, List.empty[Int])
        else
            List.empty[Int]
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    synchronizationConstraint(eventList, 6, tolerance)
}


def synchronizationConstraint7[A, B, C, D, E, F, G](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7))

    def eventList7:= 
        if (defaultTime(events7) >= timeNow) then
            List.prepend(7, List.empty[Int])
        else
            List.empty[Int]
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, eventList7)
        else
            eventList7
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    synchronizationConstraint(eventList, 7, tolerance)
}

def synchronizationConstraint8[A, B, C, D, E, F, G, H](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8))
     
    def eventList8:= 
        if (defaultTime(events8) >= timeNow) then
            List.prepend(8, List.empty[Int])
        else
            List.empty[Int]
     
    def eventList7:= 
        if (defaultTime(events7) >= timeNow) then
            List.prepend(7, eventList8)
        else
            eventList8
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, eventList7)
        else
            eventList7
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    synchronizationConstraint(eventList, 8, tolerance)
}

def synchronizationConstraint9[A, B, C, D, E, F, G, H, I](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], events9: Events[I], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8), events9))
        
    def eventList9:= 
        if (defaultTime(events9) >= timeNow) then
            List.prepend(9, List.empty[Int])
        else
            List.empty[Int]
    
    def eventList8:= 
        if (defaultTime(events8) >= timeNow) then
            List.prepend(8, eventList9)
        else
            eventList9
     
    def eventList7:= 
        if (defaultTime(events7) >= timeNow) then
            List.prepend(7, eventList8)
        else
            eventList8
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, eventList7)
        else
            eventList7
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    synchronizationConstraint(eventList, 9, tolerance)
}

def synchronizationConstraint10[A, B, C, D, E, F, G, H, I, J](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], events9: Events[I], events10: Events[J], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8), events9), events10))
    
    def eventList10:= 
        if (defaultTime(events10) >= timeNow) then
            List.prepend(10, List.empty[Int])
        else
            List.empty[Int]    
    
    def eventList9:= 
        if (defaultTime(events9) >= timeNow) then
            List.prepend(9, eventList10)
        else
            eventList10
    
    def eventList8:= 
        if (defaultTime(events8) >= timeNow) then
            List.prepend(8, eventList9)
        else
            eventList9
     
    def eventList7:= 
        if (defaultTime(events7) >= timeNow) then
            List.prepend(7, eventList8)
        else
            eventList8
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, eventList7)
        else
            eventList7
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    synchronizationConstraint(eventList, 10, tolerance)
}