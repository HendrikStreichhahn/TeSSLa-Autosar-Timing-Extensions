include "t2uHelpFunctions.tessla"

type SynchronizationEventInfo = {streamIndex: Int, eventTime: Int, fulfilled: Bool}
def synchronizationConstraint(eventIndices: Events[List[Int]], streamCount: Int, tolerance: Int): Events[Bool]:= {
    def buildSynchronizationEventInfo(streamInd: Int, evtTime: Int, flflld: Bool) : SynchronizationEventInfo:=
        {streamIndex= streamInd, eventTime= evtTime, fulfilled= flflld}

    def addEvents(existingEvents: List[SynchronizationEventInfo], newEventStreamIndices: List[Int], timeNow: Int) :
            List[SynchronizationEventInfo]:=
        static if (List_size(newEventStreamIndices) == 0) then
            existingEvents
        else
            addEvents(List_append(existingEvents,
                    buildSynchronizationEventInfo(List_head(newEventStreamIndices), timeNow, false)),
                List_tail(newEventStreamIndices), timeNow)
        
    # checks, if the events between timeNow and (timeNow-tolerance) fulfills the cluster
    def clusterFulfilled(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int, streamCount: Int): Bool :=
        mapAllTrue(fillIndecesList(events, timeNow, tolerance, buildMap(streamCount, false)))


    def fillIndecesList(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int,
            indicesList: Map[Int, Bool]): Map[Int, Bool] :=
        # no more events to check-> return indiceslist
        static if (List_size(events) == 0) then
            indicesList
        else
            # recursive call with tail of events and updated indicesList
            fillIndecesList(List_tail(events), timeNow, tolerance,
                # time of event fits-> set to true
                if (List_head(events).eventTime + tolerance >= timeNow) then
                    Map_add(indicesList, List_head(events).streamIndex, true)
                else
                    indicesList)

    # sets all Events in list to fulfilled, if not too old
    def setEventsToFulfilled(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int, streamCount: Int): 
            List[SynchronizationEventInfo] :=
        static if (List_size(events) == 0) then
            events
        else
            # set list_head to fulfilled, if not too old
            List_prepend(
                if (List_head(events).eventTime + tolerance >= timeNow) then
                    buildSynchronizationEventInfo(List_head(events).streamIndex, List_head(events).eventTime, true)
                else
                    List_head(events),
                setEventsToFulfilled(List_tail(events), timeNow, tolerance, streamCount))

    #set fulfilled state of events to true, if fulfilled
    def updateFullfilledEvents(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int, streamCount: Int):
            List[SynchronizationEventInfo]:=
        static if (clusterFulfilled(events, timeNow, tolerance, streamCount)) then
            setEventsToFulfilled(events, timeNow, tolerance, streamCount)
        else
            events

    # creates a List with all events, that are older than tolerance
    def eventsToRemove(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int):
            List[SynchronizationEventInfo] :=
        static if (List_size(events) == 0) then
            events
        else
            # head of List too old
            if(timeNow - List_head(events).eventTime > tolerance) then
                # add head of list to return list
                List_prepend(List_head(events), eventsToRemove(List_tail(events), timeNow, tolerance))
            else
                List_empty[SynchronizationEventInfo]
                # don't add head of list to return list
                #eventsToRemove(List_tail(events), timeNow, tolerance)

    # removes all events, that are older than tolerance
    def removeEvents(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int):
            List[SynchronizationEventInfo] :=
        static if (List_size(events) == 0) then
            events
        else
            # head of List too old
            if(timeNow - List_head(events).eventTime > tolerance) then
                removeEvents(List_tail(events), timeNow, tolerance)
            else
                events
                #List_prepend(List_head(events), removeEvents(List_tail(events), timeNow, tolerance))

    def noUnfulfilledRemoved(removedEvents: List[SynchronizationEventInfo]) : Bool :=
        static if (List_size(removedEvents) == 0) then
            true
        else
            noUnfulfilledRemoved(List_tail(removedEvents)) &&
                List_head(removedEvents).fulfilled
    # insert new events and set cluster to fulfilled, if possible
   def storedEventsBeforeRemove: Events[List[SynchronizationEventInfo]] :=
        slift4(slift3(last(storedEvents, eventIndices), eventIndices, time(eventIndices), addEvents),
                time(eventIndices), tolerance, streamCount, updateFullfilledEvents)
    # remove old events from list
    def storedEvents: Events[List[SynchronizationEventInfo]] := merge(
        slift3(storedEventsBeforeRemove, time(eventIndices), tolerance, removeEvents),
        List_empty[SynchronizationEventInfo])
		
	def timeOldestUnfulfilledEvent(storedEvents: List[SynchronizationEventInfo]): Int :=
		static if (List_size(storedEvents) == 0) then
			infty
		else
            if !List_head(storedEvents).fulfilled then
                List_head(storedEvents).eventTime
            else
                timeOldestUnfulfilledEvent(List_tail(storedEvents))
	
	def evaluateTimes = mergeUnit(eventIndices,
        safeDelay(slift1(storedEvents, timeOldestUnfulfilledEvent) + tolerance - time(eventIndices)+1, eventIndices))
    #Evaluation
    allPreviousTrue(slift1(slift3(storedEventsBeforeRemove, time(evaluateTimes), tolerance, eventsToRemove), noUnfulfilledRemoved))
}

def synchronizationConstraint2[A, B](events1: Events[A], events2: Events[B], tolerance: Int):
        Events[Bool]:={
    def timeNow: Events[Int] := time(mergeUnit(events1, events2))

    synchronizationConstraint(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List_empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List_empty[Int]),
        2, tolerance)
}

def synchronizationConstraint3[A, B, C](events1: Events[A], events2: Events[B], events3: Events[C], tolerance: Int):
        Events[Bool]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(events1, events2), events3))

    synchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List_empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List_empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List_empty[Int]),
        3, tolerance)
}

def synchronizationConstraint4[A, B, C, D](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        tolerance: Int): Events[Bool]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(events1, events2), events3), events4))

    synchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List_empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List_empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List_empty[Int]),
                          if (defaultTime(events4) >= timeNow) then buildList(1, 4) else List_empty[Int]),
        4, tolerance)
}

def synchronizationConstraint5[A, B, C, D, E](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], tolerance: Int): Events[Bool]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(events1, events2), events3), events4))

    synchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List_empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List_empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List_empty[Int]),
                          if (defaultTime(events4) >= timeNow) then buildList(1, 4) else List_empty[Int]),
                          if (defaultTime(events5) >= timeNow) then buildList(1, 5) else List_empty[Int]),
        5, tolerance)
}