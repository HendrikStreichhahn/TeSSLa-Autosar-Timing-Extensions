include "t2uHelpFunctions.tessla"

type SynchronizationEventInfo = {streamIndex: Int, eventTime: Int, fulfilled: Bool}
def synchronizationConstraint(eventIndices: Events[List[Int]], streamCount: Int, tolerance: Int): Events[fourValuedBoolean]:= {
    def buildSynchronizationEventInfo(streamInd: Int, evtTime: Int, flflld: Bool) : SynchronizationEventInfo:=
        {streamIndex= streamInd, eventTime= evtTime, fulfilled= flflld}

    def addEvents(existingEvents: List[SynchronizationEventInfo], newEventStreamIndices: List[Int], timeNow: Int) :
            List[SynchronizationEventInfo]:=
        if (List.size(newEventStreamIndices) == 0) then
            existingEvents
        else
            addEvents(List.append(existingEvents,
                    buildSynchronizationEventInfo(List.head(newEventStreamIndices), timeNow, false)),
                List.tail(newEventStreamIndices), timeNow)
        
    # checks, if the events between timeNow and (timeNow-tolerance) fulfills the cluster
    def clusterFulfilled(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int, streamCount: Int): Bool :=
        mapAllTrue(fillIndecesList(events, timeNow, tolerance, buildMap(streamCount, false)))


    def fillIndecesList(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int,
            indicesList: Map[Int, Bool]): Map[Int, Bool] :=
        # no more events to check-> return indiceslist
        if (List.size(events) == 0) then
            indicesList
        else
            # recursive call with tail of events and updated indicesList
            fillIndecesList(List.tail(events), timeNow, tolerance,
                # time of event fits-> set to true
                if (List.head(events).eventTime + tolerance >= timeNow) then
                    Map.add(indicesList, List.head(events).streamIndex, true)
                else
                    indicesList)

    # sets all Events in list to fulfilled, if not too old
    def setEventsToFulfilled(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int, streamCount: Int): 
            List[SynchronizationEventInfo] :=
        if (List.size(events) == 0) then
            events
        else
            # set List.head to fulfilled, if not too old
            List.prepend(
                if (List.head(events).eventTime + tolerance >= timeNow) then
                    buildSynchronizationEventInfo(List.head(events).streamIndex, List.head(events).eventTime, true)
                else
                    List.head(events),
                setEventsToFulfilled(List.tail(events), timeNow, tolerance, streamCount))

    #set fulfilled state of events to true, if fulfilled
    def updateFullfilledEvents(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int, streamCount: Int):
            List[SynchronizationEventInfo]:=
        if (clusterFulfilled(events, timeNow, tolerance, streamCount)) then
            setEventsToFulfilled(events, timeNow, tolerance, streamCount)
        else
            events

    # creates a List with all events, that are older than tolerance
    def eventsToRemove(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int):
            List[SynchronizationEventInfo] :=
        if (List.size(events) == 0) then
            events
        else
            # head of List too old
            if(timeNow - List.head(events).eventTime > tolerance) then
                # add head of list to return list
                List.prepend(List.head(events), eventsToRemove(List.tail(events), timeNow, tolerance))
            else
                # rest of list can't be older-> return empty
                List.empty[SynchronizationEventInfo]

    # removes all events, that are older than tolerance
    def removeEvents(events: List[SynchronizationEventInfo], timeNow: Int, tolerance: Int):
            List[SynchronizationEventInfo] :=
        if (List.size(events) == 0) then
            events
        else
            # head of List too old
            if(timeNow - List.head(events).eventTime > tolerance) then
                removeEvents(List.tail(events), timeNow, tolerance)
            else
                # rest of list can't be older-> return unchanged
                events

    def noUnfulfilledRemoved(removedEvents: List[SynchronizationEventInfo]) : Bool :=
        if (List.size(removedEvents) == 0) then
            true
        else
            noUnfulfilledRemoved(List.tail(removedEvents)) &&
                List.head(removedEvents).fulfilled
    # insert new events and set cluster to fulfilled, if possible
   def storedEventsBeforeRemove: Events[List[SynchronizationEventInfo]] :=
        slift4(slift3(last(storedEvents, eventIndices), eventIndices, time(eventIndices), addEvents),
                time(eventIndices), tolerance, streamCount, updateFullfilledEvents)
    # remove old events from list
    def storedEvents: Events[List[SynchronizationEventInfo]] := merge(
        slift3(storedEventsBeforeRemove, time(eventIndices), tolerance, removeEvents),
        List.empty[SynchronizationEventInfo])
		
	def timeOldestUnfulfilledEvent(storedEvents: List[SynchronizationEventInfo]): Int :=
		if (List.size(storedEvents) == 0) then
			infty
		else
            if !List.head(storedEvents).fulfilled then
                List.head(storedEvents).eventTime
            else
                timeOldestUnfulfilledEvent(List.tail(storedEvents))
	
	def evaluateTimes = mergeUnit(eventIndices,
        safeDelay(slift1(storedEvents, timeOldestUnfulfilledEvent) + tolerance - time(eventIndices)+1, eventIndices))
        
    #Evaluation
    #no unfullfilled event-> current true
    stillFulfillabe(
        if (slift1(storedEvents, timeOldestUnfulfilledEvent) == infty) then
            {value= true, final= false}
        else
            #check, if all removed events are fulfilled(had a cluster)-> current false, but not final
            if (slift1(slift3(storedEventsBeforeRemove, time(evaluateTimes), tolerance, eventsToRemove), noUnfulfilledRemoved)) then
                {value= false, final= false}
            else
                {value= false, final= true})
}

def synchronizationConstraint2[A, B](events1: Events[A], events2: Events[B], tolerance: Int):
        Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(events1, events2))

    synchronizationConstraint(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List.empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List.empty[Int]),
        2, tolerance)
}

def synchronizationConstraint3[A, B, C](events1: Events[A], events2: Events[B], events3: Events[C], tolerance: Int):
        Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(events1, events2), events3))

    synchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List.empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List.empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List.empty[Int]),
        3, tolerance)
}

def synchronizationConstraint4[A, B, C, D](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(events1, events2), events3), events4))

    synchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List.empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List.empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List.empty[Int]),
                          if (defaultTime(events4) >= timeNow) then buildList(1, 4) else List.empty[Int]),
        4, tolerance)
}

def synchronizationConstraint5[A, B, C, D, E](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5))

    synchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List.empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List.empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List.empty[Int]),
                          if (defaultTime(events4) >= timeNow) then buildList(1, 4) else List.empty[Int]),
                          if (defaultTime(events5) >= timeNow) then buildList(1, 5) else List.empty[Int]),
        5, tolerance)
}

def synchronizationConstraint6[A, B, C, D, E, F](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6))

    synchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List.empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List.empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List.empty[Int]),
                          if (defaultTime(events4) >= timeNow) then buildList(1, 4) else List.empty[Int]),
                          if (defaultTime(events5) >= timeNow) then buildList(1, 5) else List.empty[Int]),
                          if (defaultTime(events6) >= timeNow) then buildList(1, 6) else List.empty[Int]),
        6, tolerance)
}


def synchronizationConstraint7[A, B, C, D, E, F, G](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7))

    synchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List.empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List.empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List.empty[Int]),
                          if (defaultTime(events4) >= timeNow) then buildList(1, 4) else List.empty[Int]),
                          if (defaultTime(events5) >= timeNow) then buildList(1, 5) else List.empty[Int]),
                          if (defaultTime(events6) >= timeNow) then buildList(1, 6) else List.empty[Int]),
                          if (defaultTime(events7) >= timeNow) then buildList(1, 7) else List.empty[Int]),
        7, tolerance)
}

def synchronizationConstraint8[A, B, C, D, E, F, G, H](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8))

    synchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List.empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List.empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List.empty[Int]),
                          if (defaultTime(events4) >= timeNow) then buildList(1, 4) else List.empty[Int]),
                          if (defaultTime(events5) >= timeNow) then buildList(1, 5) else List.empty[Int]),
                          if (defaultTime(events6) >= timeNow) then buildList(1, 6) else List.empty[Int]),
                          if (defaultTime(events7) >= timeNow) then buildList(1, 7) else List.empty[Int]),
                          if (defaultTime(events8) >= timeNow) then buildList(1, 8) else List.empty[Int]),
        8, tolerance)
}

def synchronizationConstraint9[A, B, C, D, E, F, G, H, I](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], events9: Events[I], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8), events9))

    synchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List.empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List.empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List.empty[Int]),
                          if (defaultTime(events4) >= timeNow) then buildList(1, 4) else List.empty[Int]),
                          if (defaultTime(events5) >= timeNow) then buildList(1, 5) else List.empty[Int]),
                          if (defaultTime(events6) >= timeNow) then buildList(1, 6) else List.empty[Int]),
                          if (defaultTime(events7) >= timeNow) then buildList(1, 7) else List.empty[Int]),
                          if (defaultTime(events8) >= timeNow) then buildList(1, 8) else List.empty[Int]),
                          if (defaultTime(events9) >= timeNow) then buildList(1, 9) else List.empty[Int]),
        9, tolerance)
}

def synchronizationConstraint10[A, B, C, D, E, F, G, H, I, J](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], events9: Events[I], events10: Events[J], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8), events9), events10))

    synchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List.empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List.empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List.empty[Int]),
                          if (defaultTime(events4) >= timeNow) then buildList(1, 4) else List.empty[Int]),
                          if (defaultTime(events5) >= timeNow) then buildList(1, 5) else List.empty[Int]),
                          if (defaultTime(events6) >= timeNow) then buildList(1, 6) else List.empty[Int]),
                          if (defaultTime(events7) >= timeNow) then buildList(1, 7) else List.empty[Int]),
                          if (defaultTime(events8) >= timeNow) then buildList(1, 8) else List.empty[Int]),
                          if (defaultTime(events9) >= timeNow) then buildList(1, 9) else List.empty[Int]),
                          if (defaultTime(events10) >= timeNow) then buildList(1, 10) else List.empty[Int]),
        10, tolerance)
}