include "t2uConstraints.tessla"

def inputSynchronizationConstraint(eventStreamIndices: Events[Map[Int, Int]], stimulusStreamCount: Int, tolerance: Int):
        Events[fourValuedBoolean]:= {
    # Help functions
    def buildEmptylatestEventTimes(stimulusStreamCount: Int): Map[Int, Map[Int, Int]] :=
        if (stimulusStreamCount == 0) then
            Map.empty[Int, Map[Int, Int]]
        else
            Map.add(buildEmptylatestEventTimes(stimulusStreamCount-1), stimulusStreamCount, Map.empty[Int, Int]);

    # adds stimulus events to stored events    
    def addEventsToEmptylatestEventTimes(latestEventTimes: Map[Int, Map[Int, Int]], timeNow: Int,
            eventStreamIndices: Map[Int, Int]): Map[Int, Map[Int, Int]] :=
        addEventsToEmptylatestEventTimesRec(latestEventTimes, timeNow, eventStreamIndices, Map.keys(eventStreamIndices));
       # static if (Map.size(eventStreamIndices) == 0) then
       #     latestEventTimes
       # else
       #     # if resoponse stream -> don't insert
       #     static if (Map.headKey(eventStreamIndices) == 0) then
       #         addEventsToEmptylatestEventTimes(latestEventTimes, timeNow, Map.tail(eventStreamIndices))
       #     else
       #         # insert head of map and recursive call
       #         addEventsToEmptylatestEventTimes(
       #             Map.add(latestEventTimes, Map.headKey(eventStreamIndices), 
       #                 Map.add(Map.get(latestEventTimes, Map.headKey(eventStreamIndices)), Map.headValue(eventStreamIndices), timeNow)), 
       #             timeNow, Map.tail(eventStreamIndices))
                    
    def addEventsToEmptylatestEventTimesRec(latestEventTimes: Map[Int, Map[Int, Int]], timeNow: Int,
            eventStreamIndices: Map[Int, Int], remainingKeys: List[Int]): Map[Int, Map[Int, Int]] :=
        if (List.size(remainingKeys) == 0) then
            latestEventTimes
        else
            # if resoponse stream -> don't insert
            if (List.head(remainingKeys) == 0) then
                addEventsToEmptylatestEventTimesRec(latestEventTimes, timeNow, eventStreamIndices, List.tail(remainingKeys))
            else
                # insert head of map and recursive call
                addEventsToEmptylatestEventTimesRec(
                    Map.add(latestEventTimes, List.head(remainingKeys),
                        Map.add(Map.get(latestEventTimes, List.head(remainingKeys)), Map.get(eventStreamIndices, List.head(remainingKeys)), timeNow)), 
                    timeNow, eventStreamIndices, List.tail(remainingKeys))
    # time of the oldest event of the given color
    def timeOldestEvent(latestEvents: Map[Int, Map[Int, Int]], color: Int, remainingKeys: List[Int]): Int :=
        #static if (Map.size(latestEvents) == 0 || List.size(remainingKeys) == 0) then
        if (List.size(remainingKeys) == 0) then
            infty
        else
            if (Map.contains(Map.get(latestEvents, List.head(remainingKeys)), color)) then
                min(Map.get(Map.get(latestEvents, List.head(remainingKeys)), color),
                    timeOldestEvent(latestEvents, color, List.tail(remainingKeys)))
            else
                -infty
    
    
    
 #   def timeOldestEvent(latestEvents: Map[Int, Map[Int, Int]], color: Int): Int :=
 #       static if (Map.size(latestEvents) == 0) then
 #           infty
 #       else
 #           if (Map.contains(Map.headValue(latestEvents), color)) then
 #               min(Map.get(Map.headValue(latestEvents), color), timeOldestEvent(Map.tail(latestEvents), color))
 #           else
 #               -infty

    # time of the youngest event of the given color
    def timeYoungestEvent(latestEvents: Map[Int, Map[Int, Int]], color: Int, remainingKeys: List[Int]): Int :=
        #static if (Map.size(latestEvents) == 0 || List.size(remainingKeys) == 0) then
        if (List.size(remainingKeys) == 0) then
            -infty
        else
            if (Map.contains(Map.get(latestEvents, List.head(remainingKeys)), color)) then
                max(Map.get(Map.get(latestEvents, List.head(remainingKeys)), color),
                    timeYoungestEvent(latestEvents, color, List.tail(remainingKeys)))
            else
                infty
 #   def timeYoungestEvent(latestEvents: Map[Int, Map[Int, Int]], color: Int): Int :=
 #       static if (Map.size(latestEvents) == 0) then
 #           -infty
 #       else
 #           if (Map.contains(Map.headValue(latestEvents), color)) then
 #               max(Map.get(Map.headValue(latestEvents), color), timeYoungestEvent(Map.tail(latestEvents), color))
 #           else
 #               infty


    # checks, if the synchronization cluster for the given color is fulfilled
    def clusterFulfilled(latestEventTimes: Map[Int, Map[Int, Int]], color: Int, tolerance: Int) : Bool =
        clusterFulfilledRec(latestEventTimes, Map.keys(latestEventTimes), color, tolerance)
        #static if (Map.size(latestEventTimes) == 0) then
        #    true
        #else
        #    timeOldestEvent(latestEventTimes, color, Map.keys(latestEventTimes)) + tolerance >= timeYoungestEvent(latestEventTimes, color, Map.keys(latestEventTimes)) &&
        #    clusterFulfilled(Map.tail(latestEventTimes), color, tolerance)
            
    def clusterFulfilledRec(latestEventTimes: Map[Int, Map[Int, Int]], remainingKeys: List[Int], color: Int, tolerance: Int) : Bool =
        if (List.size(remainingKeys) == 0) then
            true
        else
            timeOldestEvent(latestEventTimes, color, remainingKeys) + tolerance >= timeYoungestEvent(latestEventTimes, color, remainingKeys) &&
            clusterFulfilledRec(latestEventTimes, List.tail(remainingKeys), color, tolerance)
        
    #stored information
    
    # time of last stimulus events with given color
    #   streamIndex -> (color -> time)
    def latestEventTimes: Events[Map[Int, Map[Int, Int]]] := 
        merge(slift3(last(latestEventTimes, time(eventStreamIndices)), time(eventStreamIndices), eventStreamIndices, addEventsToEmptylatestEventTimes),
            buildEmptylatestEventTimes(stimulusStreamCount))
    
    
    stillFulfillabe(
        if (Map.contains(eventStreamIndices, 0)) then
            if slift3(latestEventTimes, Map.get(eventStreamIndices, 0), tolerance, clusterFulfilled) then
                {value= true, final= false}
            else
                {value= false, final= true}
        else
            {value= true, final= false})
    
    #evaluation
#    allPreviousTrue(
#        # 'now' has stimulus event
#        # response event-> matching stimulus cluster exists
#        if Map.contains(eventStreamIndices, 0) then
#            #slift4(latestEventTimes, Map.get(eventStreamIndices, 0), tolerance, time(eventStreamIndices), clusterFulfilledABC)
#            slift3(latestEventTimes, Map.get(eventStreamIndices, 0), tolerance, clusterFulfilled)
#        else
#            true
#    )

}

def inputSynchronizationConstraint2(stimulus1: Events[Int], stimulus2: Events[Int], response: Events[Int],
        tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
            time(response)))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, response), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, stimulus1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, stimulus2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 2, tolerance)
}

def inputSynchronizationConstraint3(stimulus1: Events[Int], stimulus2: Events[Int], stimulus3: Events[Int],
        response: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
        merge(time(stimulus3),
            time(response))))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, response), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, stimulus1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, stimulus2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, stimulus3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 3, tolerance)
}

def inputSynchronizationConstraint4(stimulus1: Events[Int], stimulus2: Events[Int], stimulus3: Events[Int],
        stimulus4: Events[Int], response: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
        merge(time(stimulus3),
        merge(time(stimulus4),
            time(response)))))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, response), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, stimulus1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, stimulus2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, stimulus3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus4) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 4, stimulus4), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 4, tolerance)
}

def inputSynchronizationConstraint5(stimulus1: Events[Int], stimulus2: Events[Int], stimulus3: Events[Int],
        stimulus4: Events[Int], stimulus5: Events[Int], response: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
        merge(time(stimulus3),
        merge(time(stimulus4),
        merge(time(stimulus5),
            time(response))))))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, response), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, stimulus1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, stimulus2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, stimulus3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus4) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 4, stimulus4), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus5) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 5, stimulus5), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 5, tolerance)
}

def inputSynchronizationConstraint6(stimulus1: Events[Int], stimulus2: Events[Int], stimulus3: Events[Int],
        stimulus4: Events[Int], stimulus5: Events[Int], stimulus6: Events[Int], response: Events[Int],
        tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
        merge(time(stimulus3),
        merge(time(stimulus4),
        merge(time(stimulus5),
        merge(time(stimulus6),
            time(response)))))))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, response), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, stimulus1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, stimulus2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, stimulus3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus4) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 4, stimulus4), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus5) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 5, stimulus5), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus6) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 6, stimulus6), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 6, tolerance)
}

def inputSynchronizationConstraint7(stimulus1: Events[Int], stimulus2: Events[Int], stimulus3: Events[Int],
        stimulus4: Events[Int], stimulus5: Events[Int], stimulus6: Events[Int], stimulus7: Events[Int],
        response: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
        merge(time(stimulus3),
        merge(time(stimulus4),
        merge(time(stimulus5),
        merge(time(stimulus6),
        merge(time(stimulus7),
            time(response))))))))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, response), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, stimulus1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, stimulus2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, stimulus3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus4) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 4, stimulus4), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus5) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 5, stimulus5), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus6) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 6, stimulus6), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus7) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 7, stimulus7), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 7, tolerance)
}

def inputSynchronizationConstraint8(stimulus1: Events[Int], stimulus2: Events[Int], stimulus3: Events[Int],
        stimulus4: Events[Int], stimulus5: Events[Int], stimulus6: Events[Int], stimulus7: Events[Int],
        stimulus8: Events[Int], response: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
        merge(time(stimulus3),
        merge(time(stimulus4),
        merge(time(stimulus5),
        merge(time(stimulus6),
        merge(time(stimulus7),
        merge(time(stimulus8),
            time(response)))))))))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, response), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, stimulus1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, stimulus2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, stimulus3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus4) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 4, stimulus4), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus5) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 5, stimulus5), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus6) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 6, stimulus6), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus7) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 7, stimulus7), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus8) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 8, stimulus8), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 8, tolerance)
}

def inputSynchronizationConstraint9(stimulus1: Events[Int], stimulus2: Events[Int], stimulus3: Events[Int],
        stimulus4: Events[Int], stimulus5: Events[Int], stimulus6: Events[Int], stimulus7: Events[Int],
        stimulus8: Events[Int], stimulus9: Events[Int], response: Events[Int], tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
        merge(time(stimulus3),
        merge(time(stimulus4),
        merge(time(stimulus5),
        merge(time(stimulus6),
        merge(time(stimulus7),
        merge(time(stimulus8),
        merge(time(stimulus9),
            time(response))))))))))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, response), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, stimulus1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, stimulus2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, stimulus3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus4) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 4, stimulus4), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus5) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 5, stimulus5), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus6) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 6, stimulus6), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus7) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 7, stimulus7), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus8) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 8, stimulus8), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus9) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 9, stimulus9), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 9, tolerance)
}

def inputSynchronizationConstraint10(stimulus1: Events[Int], stimulus2: Events[Int], stimulus3: Events[Int],
        stimulus4: Events[Int], stimulus5: Events[Int], stimulus6: Events[Int], stimulus7: Events[Int],
        stimulus8: Events[Int], stimulus9: Events[Int], stimulus10: Events[Int], response: Events[Int],
        tolerance: Int): Events[fourValuedBoolean] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
        merge(time(stimulus3),
        merge(time(stimulus4),
        merge(time(stimulus5),
        merge(time(stimulus6),
        merge(time(stimulus7),
        merge(time(stimulus8),
        merge(time(stimulus9),
        merge(time(stimulus10),
            time(response)))))))))))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map.add(Map.empty[Int, Int], 0, response), Map.empty[Int, Int]) 
                                                   else Map.empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 1, stimulus1), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 2, stimulus2), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus3) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 3, stimulus3), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus4) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 4, stimulus4), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus5) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 5, stimulus5), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus6) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 6, stimulus6), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus7) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 7, stimulus7), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus8) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 8, stimulus8), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus9) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 9, stimulus9), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int]),
            if (defaultTime(stimulus10) >= timeNow) then merge(Map.add(Map.empty[Int, Int], 10, stimulus10), Map.empty[Int, Int])
                                                   else Map.empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 10, tolerance)
}