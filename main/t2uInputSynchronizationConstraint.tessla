include "t2uConstraints.tessla"

def inputSynchronizationConstraint(eventStreamIndices: Events[Map[Int, Int]], stimulusStreamCount: Int, tolerance: Int):
        Events[Bool]:= {
    # Help functions
    def buildEmptylatestEventTimes(stimulusStreamCount: Int): Map[Int, Map[Int, Int]] :=
        static if (stimulusStreamCount == 0) then
            Map_empty[Int, Map[Int, Int]]
        else
            Map_add(buildEmptylatestEventTimes(stimulusStreamCount-1), stimulusStreamCount, Map_empty[Int, Int]);

    # adds stimulus events to stored events    
    def addEventsToEmptylatestEventTimes(latestEventTimes: Map[Int, Map[Int, Int]], timeNow: Int,
            eventStreamIndices: Map[Int, Int]): Map[Int, Map[Int, Int]] :=
        addEventsToEmptylatestEventTimesRec(latestEventTimes, timeNow, eventStreamIndices, Map_keys(eventStreamIndices));
       # static if (Map_size(eventStreamIndices) == 0) then
       #     latestEventTimes
       # else
       #     # if resoponse stream -> don't insert
       #     static if (Map_headKey(eventStreamIndices) == 0) then
       #         addEventsToEmptylatestEventTimes(latestEventTimes, timeNow, Map_tail(eventStreamIndices))
       #     else
       #         # insert head of map and recursive call
       #         addEventsToEmptylatestEventTimes(
       #             Map_add(latestEventTimes, Map_headKey(eventStreamIndices), 
       #                 Map_add(Map_get(latestEventTimes, Map_headKey(eventStreamIndices)), Map_headValue(eventStreamIndices), timeNow)), 
       #             timeNow, Map_tail(eventStreamIndices))
                    
    def addEventsToEmptylatestEventTimesRec(latestEventTimes: Map[Int, Map[Int, Int]], timeNow: Int,
            eventStreamIndices: Map[Int, Int], remainingKeys: List[Int]): Map[Int, Map[Int, Int]] :=
        static if (List_size(remainingKeys) == 0) then
            latestEventTimes
        else
            # if resoponse stream -> don't insert
            static if (List_head(remainingKeys) == 0) then
                addEventsToEmptylatestEventTimesRec(latestEventTimes, timeNow, eventStreamIndices, List_tail(remainingKeys))
            else
                # insert head of map and recursive call
                addEventsToEmptylatestEventTimesRec(
                    Map_add(latestEventTimes, List_head(remainingKeys),
                        Map_add(Map_get(latestEventTimes, List_head(remainingKeys)), Map_get(eventStreamIndices, List_head(remainingKeys)), timeNow)), 
                    timeNow, eventStreamIndices, List_tail(remainingKeys))
    # time of the oldest event of the given color
    def timeOldestEvent(latestEvents: Map[Int, Map[Int, Int]], color: Int, remainingKeys: List[Int]): Int :=
        #static if (Map_size(latestEvents) == 0 || List_size(remainingKeys) == 0) then
        static if (List_size(remainingKeys) == 0) then
            infty
        else
            if (Map_contains(Map_get(latestEvents, List_head(remainingKeys)), color)) then
                min(Map_get(Map_get(latestEvents, List_head(remainingKeys)), color),
                    timeOldestEvent(latestEvents, color, List_tail(remainingKeys)))
            else
                -infty
    
    
    
 #   def timeOldestEvent(latestEvents: Map[Int, Map[Int, Int]], color: Int): Int :=
 #       static if (Map_size(latestEvents) == 0) then
 #           infty
 #       else
 #           if (Map_contains(Map_headValue(latestEvents), color)) then
 #               min(Map_get(Map_headValue(latestEvents), color), timeOldestEvent(Map_tail(latestEvents), color))
 #           else
 #               -infty

    # time of the youngest event of the given color
    def timeYoungestEvent(latestEvents: Map[Int, Map[Int, Int]], color: Int, remainingKeys: List[Int]): Int :=
        #static if (Map_size(latestEvents) == 0 || List_size(remainingKeys) == 0) then
        static if (List_size(remainingKeys) == 0) then
            -infty
        else
            if (Map_contains(Map_get(latestEvents, List_head(remainingKeys)), color)) then
                max(Map_get(Map_get(latestEvents, List_head(remainingKeys)), color),
                    timeYoungestEvent(latestEvents, color, List_tail(remainingKeys)))
            else
                infty
 #   def timeYoungestEvent(latestEvents: Map[Int, Map[Int, Int]], color: Int): Int :=
 #       static if (Map_size(latestEvents) == 0) then
 #           -infty
 #       else
 #           if (Map_contains(Map_headValue(latestEvents), color)) then
 #               max(Map_get(Map_headValue(latestEvents), color), timeYoungestEvent(Map_tail(latestEvents), color))
 #           else
 #               infty


    # checks, if the synchronization cluster for the given color is fulfilled
    def clusterFulfilledABC(latestEventTimes: Map[Int, Map[Int, Int]], color: Int, tolerance: Int) : Bool =
        clusterFulfilledRec(latestEventTimes, Map_keys(latestEventTimes), color, tolerance)
        #static if (Map_size(latestEventTimes) == 0) then
        #    true
        #else
        #    timeOldestEvent(latestEventTimes, color, Map_keys(latestEventTimes)) + tolerance >= timeYoungestEvent(latestEventTimes, color, Map_keys(latestEventTimes)) &&
        #    clusterFulfilled(Map_tail(latestEventTimes), color, tolerance)
            
    def clusterFulfilledRec(latestEventTimes: Map[Int, Map[Int, Int]], remainingKeys: List[Int], color: Int, tolerance: Int) : Bool =
        static if (List_size(remainingKeys) == 0) then
            true
        else
            timeOldestEvent(latestEventTimes, color, remainingKeys) + tolerance >= timeYoungestEvent(latestEventTimes, color, remainingKeys) &&
            clusterFulfilledRec(latestEventTimes, List_tail(remainingKeys), color, tolerance)
        
    #stored information
    
    # time of last stimulus events with given color
    #   streamIndex -> (color -> time)
    def latestEventTimes: Events[Map[Int, Map[Int, Int]]] := 
        merge(slift3(last(latestEventTimes, time(eventStreamIndices)), time(eventStreamIndices), eventStreamIndices, addEventsToEmptylatestEventTimes),
            buildEmptylatestEventTimes(stimulusStreamCount))
    
    #evaluation
    allPreviousTrue(
        # 'now' has stimulus event
        # response event-> matching stimulus cluster exists
        if Map_contains(eventStreamIndices, 0) then
            #slift4(latestEventTimes, Map_get(eventStreamIndices, 0), tolerance, time(eventStreamIndices), clusterFulfilledABC)
            slift3(latestEventTimes, Map_get(eventStreamIndices, 0), tolerance, clusterFulfilledABC)
        else
            true
    )

}

def inputSynchronizationConstraint2(stimulus1: Events[Int], stimulus2: Events[Int], response: Events[Int],
        tolerance: Int): Events[Bool] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
            time(response)))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map_add(Map_empty[Int, Int], 0, response), Map_empty[Int, Int]) 
                                                   else Map_empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 1, stimulus1), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 2, stimulus2), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 2, tolerance)
}

def inputSynchronizationConstraint3(stimulus1: Events[Int], stimulus2: Events[Int], stimulus3: Events[Int],
        response: Events[Int], tolerance: Int): Events[Bool] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
        merge(time(stimulus3),
            time(response))))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map_add(Map_empty[Int, Int], 0, response), Map_empty[Int, Int]) 
                                                   else Map_empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 1, stimulus1), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 2, stimulus2), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus3) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 3, stimulus3), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 3, tolerance)
}

def inputSynchronizationConstraint4(stimulus1: Events[Int], stimulus2: Events[Int], stimulus3: Events[Int],
        stimulus4: Events[Int], response: Events[Int], tolerance: Int): Events[Bool] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
        merge(time(stimulus3),
        merge(time(stimulus4),
            time(response)))))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map_add(Map_empty[Int, Int], 0, response), Map_empty[Int, Int]) 
                                                   else Map_empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 1, stimulus1), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 2, stimulus2), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus3) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 3, stimulus3), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus4) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 4, stimulus4), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 4, tolerance)
}

def inputSynchronizationConstraint5(stimulus1: Events[Int], stimulus2: Events[Int], stimulus3: Events[Int],
        stimulus4: Events[Int], stimulus5: Events[Int], response: Events[Int], tolerance: Int): Events[Bool] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
        merge(time(stimulus3),
        merge(time(stimulus4),
        merge(time(stimulus5),
            time(response))))))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map_add(Map_empty[Int, Int], 0, response), Map_empty[Int, Int]) 
                                                   else Map_empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 1, stimulus1), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 2, stimulus2), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus3) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 3, stimulus3), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus4) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 4, stimulus4), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus5) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 5, stimulus5), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 5, tolerance)
}

def inputSynchronizationConstraint6(stimulus1: Events[Int], stimulus2: Events[Int], stimulus3: Events[Int],
        stimulus4: Events[Int], stimulus5: Events[Int], stimulus6: Events[Int], response: Events[Int],
        tolerance: Int): Events[Bool] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
        merge(time(stimulus3),
        merge(time(stimulus4),
        merge(time(stimulus5),
        merge(time(stimulus6),
            time(response)))))))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map_add(Map_empty[Int, Int], 0, response), Map_empty[Int, Int]) 
                                                   else Map_empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 1, stimulus1), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 2, stimulus2), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus3) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 3, stimulus3), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus4) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 4, stimulus4), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus5) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 5, stimulus5), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus6) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 6, stimulus6), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 6, tolerance)
}

def inputSynchronizationConstraint7(stimulus1: Events[Int], stimulus2: Events[Int], stimulus3: Events[Int],
        stimulus4: Events[Int], stimulus5: Events[Int], stimulus6: Events[Int], stimulus7: Events[Int],
        response: Events[Int], tolerance: Int): Events[Bool] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
        merge(time(stimulus3),
        merge(time(stimulus4),
        merge(time(stimulus5),
        merge(time(stimulus6),
        merge(time(stimulus7),
            time(response))))))))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map_add(Map_empty[Int, Int], 0, response), Map_empty[Int, Int]) 
                                                   else Map_empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 1, stimulus1), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 2, stimulus2), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus3) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 3, stimulus3), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus4) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 4, stimulus4), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus5) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 5, stimulus5), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus6) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 6, stimulus6), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus7) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 7, stimulus7), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 7, tolerance)
}

def inputSynchronizationConstraint8(stimulus1: Events[Int], stimulus2: Events[Int], stimulus3: Events[Int],
        stimulus4: Events[Int], stimulus5: Events[Int], stimulus6: Events[Int], stimulus7: Events[Int],
        stimulus8: Events[Int], response: Events[Int], tolerance: Int): Events[Bool] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
        merge(time(stimulus3),
        merge(time(stimulus4),
        merge(time(stimulus5),
        merge(time(stimulus6),
        merge(time(stimulus7),
        merge(time(stimulus8),
            time(response)))))))))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map_add(Map_empty[Int, Int], 0, response), Map_empty[Int, Int]) 
                                                   else Map_empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 1, stimulus1), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 2, stimulus2), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus3) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 3, stimulus3), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus4) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 4, stimulus4), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus5) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 5, stimulus5), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus6) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 6, stimulus6), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus7) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 7, stimulus7), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus8) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 8, stimulus8), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 8, tolerance)
}

def inputSynchronizationConstraint9(stimulus1: Events[Int], stimulus2: Events[Int], stimulus3: Events[Int],
        stimulus4: Events[Int], stimulus5: Events[Int], stimulus6: Events[Int], stimulus7: Events[Int],
        stimulus8: Events[Int], stimulus9: Events[Int], response: Events[Int], tolerance: Int): Events[Bool] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
        merge(time(stimulus3),
        merge(time(stimulus4),
        merge(time(stimulus5),
        merge(time(stimulus6),
        merge(time(stimulus7),
        merge(time(stimulus8),
        merge(time(stimulus9),
            time(response))))))))))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map_add(Map_empty[Int, Int], 0, response), Map_empty[Int, Int]) 
                                                   else Map_empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 1, stimulus1), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 2, stimulus2), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus3) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 3, stimulus3), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus4) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 4, stimulus4), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus5) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 5, stimulus5), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus6) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 6, stimulus6), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus7) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 7, stimulus7), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus8) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 8, stimulus8), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus9) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 9, stimulus9), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 9, tolerance)
}

def inputSynchronizationConstraint10(stimulus1: Events[Int], stimulus2: Events[Int], stimulus3: Events[Int],
        stimulus4: Events[Int], stimulus5: Events[Int], stimulus6: Events[Int], stimulus7: Events[Int],
        stimulus8: Events[Int], stimulus9: Events[Int], stimulus10: Events[Int], response: Events[Int],
        tolerance: Int): Events[Bool] := {
    def timeNow = 
        merge(time(stimulus1),
        merge(time(stimulus2),
        merge(time(stimulus3),
        merge(time(stimulus4),
        merge(time(stimulus5),
        merge(time(stimulus6),
        merge(time(stimulus7),
        merge(time(stimulus8),
        merge(time(stimulus9),
        merge(time(stimulus10),
            time(response)))))))))))

    def eventStreamIndices: Events[Map[Int, Int]]:=
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
        Map_attachIntIntLifted(
            if (defaultTime(response)  >= timeNow) then merge(Map_add(Map_empty[Int, Int], 0, response), Map_empty[Int, Int]) 
                                                   else Map_empty[Int, Int],
            if (defaultTime(stimulus1) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 1, stimulus1), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus2) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 2, stimulus2), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus3) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 3, stimulus3), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus4) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 4, stimulus4), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus5) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 5, stimulus5), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus6) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 6, stimulus6), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus7) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 7, stimulus7), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus8) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 8, stimulus8), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus9) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 9, stimulus9), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int]),
            if (defaultTime(stimulus10) >= timeNow) then merge(Map_add(Map_empty[Int, Int], 10, stimulus10), Map_empty[Int, Int])
                                                   else Map_empty[Int, Int])
    inputSynchronizationConstraint(eventStreamIndices, 10, tolerance)
}