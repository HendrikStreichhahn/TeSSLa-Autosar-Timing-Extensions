include "t2uHelpFunctions.tessla"

# State information for currently active snchronization clusters
#   startTime: startTime of the cluster (timestamp of first event in this cluster)
#   fulfilledStreams.key:   Indices of all streams
#   fulfilledStreams.value: event in this stream for this cluster?
## nodoc
type synchronizationCluster = {startTime: Int, fulfilledStreams: Map[Int, Bool]}

## Checks the StrongSynchronizationConstraint defined in TADL2.
## The StrongSynchronizationConstraint describes groups of streams, which events occur in common clusters. Each of these streams must have exactly one event in each of these intervals. Any events that lay outside of these intervals are prohibited. Overlaps of clusters are allowed.
## The events of each input timestamp must be placed into an integer list, which contains the index (starting at 1) of all streams, which have an event in this timestamp. This list is then used as a parameter for the implementation. The creation of this list is already implemented for up to 10 streams. See synchronizationConstraint2, ... .
##
## **Usage Example**
##
## ~~~tessla
## in event1: Events[Unit]
## in event2: Events[Unit]
## in event3: Events[Unit]
##
## def constraint= StrongSynchronizationConstraint3(event1, event2, event3, 2)
## out constraint
##~~~
##
## **Trace Example**
##
## ~~~trace
## option timeDomain:[-1,50]
## 5: event1
## 5: event2
## 5: event3
## 15: event1
## 15: event2
## 15: event3
## 24: event1
## 25: event2
## 26: event3
## 36: event1
## 34: event2
## 35: event3
## ~~~
def StrongSynchronizationConstraint(eventIndices: Events[List[Int]], streamCount: Int, tolerance: Int): Events[fourValuedBoolean]:= {

    # inserts one events to the active clusters. Creates new cluster, if needed.
    # insertes only, if cluster not too old
    # runtime: list.length(activeClusters)
    liftable def insertEvent(activeClusters: List[synchronizationCluster], eventIndex: Int, timeNow: Int): List[synchronizationCluster] :=
        # no more clusters to check -> create new cluster
        if (List.size(activeClusters) == 0) then
            List.append(activeClusters, {startTime= timeNow, 
                fulfilledStreams= Map.add(buildMap(streamCount, false), eventIndex, true)})
        else
            # stream index already was in head cluster or too old-> check next one
            if (Map.get(List.head(activeClusters).fulfilledStreams, eventIndex) ||
                    List.head(activeClusters).startTime + tolerance < timeNow) then
                List.prepend(List.head(activeClusters), insertEvent(List.tail(activeClusters), eventIndex, timeNow))
            #found matching cluster-> set stream in this cluster to true
            else
                List.prepend({startTime= List.head(activeClusters).startTime, 
                            fulfilledStreams= Map.add(List.head(activeClusters).fulfilledStreams, eventIndex, true)},
                    List.tail(activeClusters))
    
    # inserts all events from eventIndices to the active clusters.
    # runtime: List.length(eventIndices) * list.length(activeClusters)
    liftable def insertEventsList(activeClusters: List[synchronizationCluster], eventIndices: List[Int], timeNow: Int): List[synchronizationCluster] :=
        if (List.size(eventIndices) == 0) then
            activeClusters
        else
            insertEventsList(insertEvent(activeClusters, List.head(eventIndices), timeNow), 
                List.tail(eventIndices), timeNow)
    
    # runtime: min(tolerance, List.length(eventIndices) * list.length(activeClusters))
    liftable def removeFulfilledClusters(activeClusters: List[synchronizationCluster]): List[synchronizationCluster]:=
        #head of list is fulfilled-> remove and check next list entry
        if (List.size(activeClusters) != 0 && mapAllTrue(List.head(activeClusters).fulfilledStreams)) then
            removeFulfilledClusters(List.tail(activeClusters))
        # head of list is unfulfilled-> don't remove, rest can't be fulfilled either
        else
            activeClusters
            
    #state
    # list of active clusters
    def activeClusters: Events[List[synchronizationCluster]]:=
        merge(removeFulfilledClusters(insertEventsList(last(activeClusters, eventIndices),
                eventIndices, time(eventIndices))),
            List.empty[synchronizationCluster])
    #delay
    def evalTimes:= 
        time(mergeUnit(eventIndices,
            safeDelay(if (List.size(activeClusters) != 0) then
                     List.head(activeClusters).startTime+ tolerance - time(eventIndices)+1
                 else
                    infty, eventIndices)))
    
    #no unfulfilled clusters-> current true
    stillFulfillabe(if List.size(activeClusters) == 0 then
        {value= true, final= false}
    else
        # unfulfilled clusters exists, but not too old-> current false
        if (List.head(activeClusters).startTime + tolerance > evalTimes) then
            {value= false, final= false}
        else
            # unfulfilled clusters are too old-> def. false
            {value= false, final= true})
}

## checks the StrongSynchronizationConstraint for two streams.
## See StrongSynchronizationConstraint for further information.
def StrongSynchronizationConstraint2[A, B](events1: Events[A], events2: Events[B], tolerance: Int):
        Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(events1, events2))
    
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, List.empty[Int])
        else
            List.empty[Int]
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList2, 2, tolerance)
}

## checks the StrongSynchronizationConstraint for three streams.
## See StrongSynchronizationConstraint for further information.
def StrongSynchronizationConstraint3[A, B, C](events1: Events[A], events2: Events[B], events3: Events[C], tolerance: Int):
        Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(events1, events2), events3))
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, List.empty[Int])
        else
            List.empty[Int]
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 3, tolerance)
}

## checks the StrongSynchronizationConstraint for four streams.
## See StrongSynchronizationConstraint for further information.
def StrongSynchronizationConstraint4[A, B, C, D](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(events1, events2), events3), events4))
    
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, List.empty[Int])
        else
            List.empty[Int]
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 4, tolerance)
}

## checks the StrongSynchronizationConstraint for five streams.
## See StrongSynchronizationConstraint for further information.
def StrongSynchronizationConstraint5[A, B, C, D, E](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5))
     
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, List.empty[Int])
        else
            List.empty[Int]
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 5, tolerance)
}

## checks the StrongSynchronizationConstraint for six streams.
## See StrongSynchronizationConstraint for further information.
def StrongSynchronizationConstraint6[A, B, C, D, E, F](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6))
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, List.empty[Int])
        else
            List.empty[Int]
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 6, tolerance)
}


## checks the StrongSynchronizationConstraint for seven streams.
## See StrongSynchronizationConstraint for further information.
def StrongSynchronizationConstraint7[A, B, C, D, E, F, G](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7))

    def eventList7:= 
        if (defaultTime(events7) >= timeNow) then
            List.prepend(7, List.empty[Int])
        else
            List.empty[Int]
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, eventList7)
        else
            eventList7
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 7, tolerance)
}


## checks the StrongSynchronizationConstraint for eight streams.
## See StrongSynchronizationConstraint for further information.
def StrongSynchronizationConstraint8[A, B, C, D, E, F, G, H](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8))
     
    def eventList8:= 
        if (defaultTime(events8) >= timeNow) then
            List.prepend(8, List.empty[Int])
        else
            List.empty[Int]
     
    def eventList7:= 
        if (defaultTime(events7) >= timeNow) then
            List.prepend(7, eventList8)
        else
            eventList8
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, eventList7)
        else
            eventList7
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 8, tolerance)
}


## checks the StrongSynchronizationConstraint for nine streams.
## See StrongSynchronizationConstraint for further information.
def StrongSynchronizationConstraint9[A, B, C, D, E, F, G, H, I](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], events9: Events[I], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8), events9))
        
    def eventList9:= 
        if (defaultTime(events9) >= timeNow) then
            List.prepend(9, List.empty[Int])
        else
            List.empty[Int]
    
    def eventList8:= 
        if (defaultTime(events8) >= timeNow) then
            List.prepend(8, eventList9)
        else
            eventList9
     
    def eventList7:= 
        if (defaultTime(events7) >= timeNow) then
            List.prepend(7, eventList8)
        else
            eventList8
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, eventList7)
        else
            eventList7
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 9, tolerance)
}

## checks the StrongSynchronizationConstraint for ten streams.
## See StrongSynchronizationConstraint for further information.
def StrongSynchronizationConstraint10[A, B, C, D, E, F, G, H, I, J](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], events9: Events[I], events10: Events[J], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8), events9), events10))
    
    def eventList10:= 
        if (defaultTime(events10) >= timeNow) then
            List.prepend(10, List.empty[Int])
        else
            List.empty[Int]    
    
    def eventList9:= 
        if (defaultTime(events9) >= timeNow) then
            List.prepend(9, eventList10)
        else
            eventList10
    
    def eventList8:= 
        if (defaultTime(events8) >= timeNow) then
            List.prepend(8, eventList9)
        else
            eventList9
     
    def eventList7:= 
        if (defaultTime(events7) >= timeNow) then
            List.prepend(7, eventList8)
        else
            eventList8
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, eventList7)
        else
            eventList7
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 10, tolerance)
}