include "t2uHelpFunctions.tessla"

type synchronizationCluster = {xTime: Int, fulfilledStreams: Map[Int, Bool]}

def StrongSynchronizationConstraint(eventIndices: Events[List[Int]], streamCount: Int, tolerance: Int): Events[Bool]:= {

    def SynchronizationCluster(aTime: Int, aFulfilledStreams: Map[Int, Bool]): synchronizationCluster :=
        {xTime = aTime, fulfilledStreams = aFulfilledStreams}
        
    def buildSynchronizationCluster(time: Int, streamCount: Int): synchronizationCluster :=
        {xTime = time, fulfilledStreams = buildMap(streamCount, false)}
        
    def getXTime(cluster: synchronizationCluster): Int :=
        cluster.xTime
        
    def getXTimeLifted(cluster: Events[synchronizationCluster]): Events[Int] :=
        slift1(cluster, getXTime)

    #checks if a cluster exists, where the event would fit
    def existsMatchingCluster(
            activeClusters: List[synchronizationCluster],   # List of actice clusters
            eventStreamIndex: Int): Bool:=                        # the index of the stream, where the event has occurred
        # list empty-> no matching cluster found
        static if (List_size(activeClusters) == 0) then
            false
        else
            # var in map is true-> stream has already event in stream
            if (Map_get(List_head(activeClusters).fulfilledStreams, eventStreamIndex)) then
                existsMatchingCluster(List_tail(activeClusters), eventStreamIndex)
            # var in map is false-> event does fit in this cluster
            else
                true

    def clusterFulfilled(fulfilledStreams: Map[Int, Bool], keys: List[Int]): Bool :=
        # list is empty
        static if (Map_size(fulfilledStreams) == 0 || List_size(keys) == 0) then
            true
        else
            # now checked stream is fulfilled
            static if Map_get(fulfilledStreams, List_head(keys)) then
                # all following streams are fulfilled
                clusterFulfilled(fulfilledStreams, List_tail(keys))
            else
                false
                
    def removeFulfilled(activeClusters: List[synchronizationCluster]) : List[synchronizationCluster] :=
        static if (List_size(activeClusters) == 0) then
            activeClusters
        else
            if clusterFulfilled(List_head(activeClusters).fulfilledStreams,
                    Map_keys(List_head(activeClusters).fulfilledStreams)) then
                removeFulfilled(List_tail(activeClusters))
            else
                List_prepend(List_head(activeClusters), removeFulfilled(List_tail(activeClusters)))
            
    def addEventToClusterList(activeClusters: List[synchronizationCluster], eventStreamIndex: Int):
            List[synchronizationCluster]:= 
        # new event doesn't fit in head of list-> check next one
        static if Map_get(List_head(activeClusters).fulfilledStreams, eventStreamIndex) then
            List_prepend(List_head(activeClusters),
                addEventToClusterList(List_tail(activeClusters), eventStreamIndex))
        else
            #set event to fulfilled
            List_prepend(SynchronizationCluster(List_head(activeClusters).xTime, 
                        Map_add(List_head(activeClusters).fulfilledStreams, eventStreamIndex, true)),
                List_tail(activeClusters))
                
    def addEventsToClusters(activeClusters: List[synchronizationCluster], eventIndices: List[Int], time: Int, streamCount: Int) : List[synchronizationCluster]:=
        static if (List_size(eventIndices) == 0) then
            activeClusters
        else
            # recursive call-> do for all events in list
            addEventsToClusters(
                # remove clusters, that don't take more events
                    addEventToClusterList(#List_empty[synchronizationCluster], 
                        List_attach(activeClusters, if existsMatchingCluster(activeClusters, List_head(eventIndices))
                                                        then List_empty[synchronizationCluster]
                                                        else List_append(List_empty[synchronizationCluster],
                                                            buildSynchronizationCluster(time, streamCount))),
                    List_head(eventIndices)), 
                List_tail(eventIndices), time, streamCount)
    
    def evaluateTimes: Events[Int] := time(mergeUnit(eventIndices,
        safeDelay(if (List_size(activeClusters) != 0) then
                     getXTimeLifted(List_head(activeClusters))+ tolerance - time(eventIndices)+1
                 else
                    infty, eventIndices)))
                    
    #active clusters with new events
    def activeClustersNewEvent : Events[List[synchronizationCluster]] :=
        slift4(last(activeClusters, eventIndices), eventIndices, evaluateTimes, streamCount, addEventsToClusters)
    # active clusters after removing of full clusters
    def activeClusters: Events[List[synchronizationCluster]] := merge(
        slift1(activeClustersNewEvent, removeFulfilled), 
        List_empty[synchronizationCluster])
    allPreviousTrue(List_size(activeClustersNewEvent) == 0 ||
        getXTimeLifted(List_head(activeClustersNewEvent)) +
            tolerance >= evaluateTimes)
}

def StrongSynchronizationConstraint2[A, B](events1: Events[A], events2: Events[B], tolerance: Int): Events[Bool]:={
    def timeNow: Events[Int] := time(mergeUnit(events1, events2))

    StrongSynchronizationConstraint(
        slift(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List_empty[Int],
              if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List_empty[Int],
              List_attachInt),
        2, tolerance)
}

def StrongSynchronizationConstraint3[A, B, C](events1: Events[A], events2: Events[B], events3: Events[C], tolerance: Int):
        Events[Bool]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(events1, events2), events3))

    StrongSynchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List_empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List_empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List_empty[Int]),
        3, tolerance)
}

def StrongSynchronizationConstraint4[A, B, C, D](events1: Events[A], events2: Events[B], events3: Events[C],
        events4: Events[D], tolerance: Int): Events[Bool]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(events1, events2), events3), events4))

    StrongSynchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List_empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List_empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List_empty[Int]),
                          if (defaultTime(events4) >= timeNow) then buildList(1, 4) else List_empty[Int]),
        4, tolerance)
}

def StrongSynchronizationConstraint5[A, B, C, D, E](events1: Events[A], events2: Events[B], events3: Events[C],
        events4: Events[D], events5: Events[E], tolerance: Int): Events[Bool]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(events1, events2), events3), events4), events5))

    StrongSynchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List_empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List_empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List_empty[Int]),
                          if (defaultTime(events4) >= timeNow) then buildList(1, 4) else List_empty[Int]),
                          if (defaultTime(events5) >= timeNow) then buildList(1, 5) else List_empty[Int]),
        5, tolerance)
}


def StrongSynchronizationConstraint6[A, B, C, D, E, F](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], tolerance: Int): Events[Bool]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6))

    StrongSynchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List_empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List_empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List_empty[Int]),
                          if (defaultTime(events4) >= timeNow) then buildList(1, 4) else List_empty[Int]),
                          if (defaultTime(events5) >= timeNow) then buildList(1, 5) else List_empty[Int]),
                          if (defaultTime(events6) >= timeNow) then buildList(1, 6) else List_empty[Int]),
        6, tolerance)
}


def StrongSynchronizationConstraint7[A, B, C, D, E, F, G](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], tolerance: Int): Events[Bool]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7))

    StrongSynchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List_empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List_empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List_empty[Int]),
                          if (defaultTime(events4) >= timeNow) then buildList(1, 4) else List_empty[Int]),
                          if (defaultTime(events5) >= timeNow) then buildList(1, 5) else List_empty[Int]),
                          if (defaultTime(events6) >= timeNow) then buildList(1, 6) else List_empty[Int]),
                          if (defaultTime(events7) >= timeNow) then buildList(1, 7) else List_empty[Int]),
        7, tolerance)
}

def StrongSynchronizationConstraint8[A, B, C, D, E, F, G, H](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], tolerance: Int): Events[Bool]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8))

    StrongSynchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List_empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List_empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List_empty[Int]),
                          if (defaultTime(events4) >= timeNow) then buildList(1, 4) else List_empty[Int]),
                          if (defaultTime(events5) >= timeNow) then buildList(1, 5) else List_empty[Int]),
                          if (defaultTime(events6) >= timeNow) then buildList(1, 6) else List_empty[Int]),
                          if (defaultTime(events7) >= timeNow) then buildList(1, 7) else List_empty[Int]),
                          if (defaultTime(events8) >= timeNow) then buildList(1, 8) else List_empty[Int]),
        8, tolerance)
}

def StrongSynchronizationConstraint9[A, B, C, D, E, F, G, H, I](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], events9: Events[I], tolerance: Int): Events[Bool]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8), events9))

    StrongSynchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List_empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List_empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List_empty[Int]),
                          if (defaultTime(events4) >= timeNow) then buildList(1, 4) else List_empty[Int]),
                          if (defaultTime(events5) >= timeNow) then buildList(1, 5) else List_empty[Int]),
                          if (defaultTime(events6) >= timeNow) then buildList(1, 6) else List_empty[Int]),
                          if (defaultTime(events7) >= timeNow) then buildList(1, 7) else List_empty[Int]),
                          if (defaultTime(events8) >= timeNow) then buildList(1, 8) else List_empty[Int]),
                          if (defaultTime(events9) >= timeNow) then buildList(1, 9) else List_empty[Int]),
        9, tolerance)
}

def StrongSynchronizationConstraint10[A, B, C, D, E, F, G, H, I, J](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], events9: Events[I], events10: Events[J], tolerance: Int): Events[Bool]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8), events9), events10))

    StrongSynchronizationConstraint(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(
        List_attachIntLifted(if (defaultTime(events1) >= timeNow) then buildList(1, 1) else List_empty[Int],
                          if (defaultTime(events2) >= timeNow) then buildList(1, 2) else List_empty[Int]),
                          if (defaultTime(events3) >= timeNow) then buildList(1, 3) else List_empty[Int]),
                          if (defaultTime(events4) >= timeNow) then buildList(1, 4) else List_empty[Int]),
                          if (defaultTime(events5) >= timeNow) then buildList(1, 5) else List_empty[Int]),
                          if (defaultTime(events6) >= timeNow) then buildList(1, 6) else List_empty[Int]),
                          if (defaultTime(events7) >= timeNow) then buildList(1, 7) else List_empty[Int]),
                          if (defaultTime(events8) >= timeNow) then buildList(1, 8) else List_empty[Int]),
                          if (defaultTime(events9) >= timeNow) then buildList(1, 9) else List_empty[Int]),
                          if (defaultTime(events10) >= timeNow) then buildList(1, 10) else List_empty[Int]),
        10, tolerance)
}