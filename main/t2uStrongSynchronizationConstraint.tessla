include "t2uHelpFunctions.tessla"

# State information for currently active snchronization clusters
#   startTime: startTime of the cluster (timestamp of first event in this cluster)
#   fulfilledStreams.key:   Indices of all streams
#   fulfilledStreams.value: event in this stream for this cluster?
type synchronizationCluster = {startTime: Int, fulfilledStreams: Map[Int, Bool]}

def StrongSynchronizationConstraint(eventIndices: Events[List[Int]], streamCount: Int, tolerance: Int): Events[fourValuedBoolean]:= {

    # inserts one events to the active clusters. Creates new cluster, if needed.
    # insertes only, if cluster not too old
    # runtime: list.length(activeClusters)
    liftable def insertEvent(activeClusters: List[synchronizationCluster], eventIndex: Int, timeNow: Int): List[synchronizationCluster] :=
        # no more clusters to check -> create new cluster
        if (List.size(activeClusters) == 0) then
            List.append(activeClusters, {startTime= timeNow, 
                fulfilledStreams= Map.add(buildMap(streamCount, false), eventIndex, true)})
        else
            # stream index already was in head cluster or too old-> check next one
            if (Map.get(List.head(activeClusters).fulfilledStreams, eventIndex) ||
                    List.head(activeClusters).startTime + tolerance < timeNow) then
                List.prepend(List.head(activeClusters), insertEvent(List.tail(activeClusters), eventIndex, timeNow))
            #found matching cluster-> set stream in this cluster to true
            else
                List.prepend({startTime= List.head(activeClusters).startTime, 
                            fulfilledStreams= Map.add(List.head(activeClusters).fulfilledStreams, eventIndex, true)},
                    List.tail(activeClusters))
    
    # inserts all events from eventIndices to the active clusters.
    # runtime: List.length(eventIndices) * list.length(activeClusters)
    liftable def insertEventsList(activeClusters: List[synchronizationCluster], eventIndices: List[Int], timeNow: Int): List[synchronizationCluster] :=
        if (List.size(eventIndices) == 0) then
            activeClusters
        else
            insertEventsList(insertEvent(activeClusters, List.head(eventIndices), timeNow), 
                List.tail(eventIndices), timeNow)
    
    # runtime: min(tolerance, List.length(eventIndices) * list.length(activeClusters))
    liftable def removeFulfilledClusters(activeClusters: List[synchronizationCluster]): List[synchronizationCluster]:=
        #head of list is fulfilled-> remove and check next list entry
        if (List.size(activeClusters) != 0 && mapAllTrue(List.head(activeClusters).fulfilledStreams)) then
            removeFulfilledClusters(List.tail(activeClusters))
        # head of list is unfulfilled-> don't remove, rest can't be fulfilled either
        else
            activeClusters
            
    #state
    # list of active clusters
    def activeClusters: Events[List[synchronizationCluster]]:=
        merge(removeFulfilledClusters(insertEventsList(last(activeClusters, eventIndices),
                eventIndices, time(eventIndices))),
            List.empty[synchronizationCluster])
    #delay
    def evalTimes:= 
        time(mergeUnit(eventIndices,
            safeDelay(if (List.size(activeClusters) != 0) then
                     List.head(activeClusters).startTime+ tolerance - time(eventIndices)+1
                 else
                    infty, eventIndices)))
    
    #no unfulfilled clusters-> current true
    stillFulfillabe(if List.size(activeClusters) == 0 then
        {value= true, final= false}
    else
        # unfulfilled clusters exists, but not too old-> current false
        if (List.head(activeClusters).startTime + tolerance > evalTimes) then
            {value= false, final= false}
        else
            # unfulfilled clusters are too old-> def. false
            {value= false, final= true})
}

def StrongSynchronizationConstraint2[A, B](events1: Events[A], events2: Events[B], tolerance: Int):
        Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(events1, events2))
    
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, List.empty[Int])
        else
            List.empty[Int]
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList2, 2, tolerance)
}

def StrongSynchronizationConstraint3[A, B, C](events1: Events[A], events2: Events[B], events3: Events[C], tolerance: Int):
        Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(events1, events2), events3))
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, List.empty[Int])
        else
            List.empty[Int]
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 3, tolerance)
}

def StrongSynchronizationConstraint4[A, B, C, D](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(events1, events2), events3), events4))
    
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, List.empty[Int])
        else
            List.empty[Int]
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 4, tolerance)
}

def StrongSynchronizationConstraint5[A, B, C, D, E](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5))
     
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, List.empty[Int])
        else
            List.empty[Int]
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 5, tolerance)
}

def StrongSynchronizationConstraint6[A, B, C, D, E, F](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6))
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, List.empty[Int])
        else
            List.empty[Int]
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 6, tolerance)
}


def StrongSynchronizationConstraint7[A, B, C, D, E, F, G](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7))

    def eventList7:= 
        if (defaultTime(events7) >= timeNow) then
            List.prepend(7, List.empty[Int])
        else
            List.empty[Int]
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, eventList7)
        else
            eventList7
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 7, tolerance)
}

def StrongSynchronizationConstraint8[A, B, C, D, E, F, G, H](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8))
     
    def eventList8:= 
        if (defaultTime(events8) >= timeNow) then
            List.prepend(8, List.empty[Int])
        else
            List.empty[Int]
     
    def eventList7:= 
        if (defaultTime(events7) >= timeNow) then
            List.prepend(7, eventList8)
        else
            eventList8
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, eventList7)
        else
            eventList7
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 8, tolerance)
}

def StrongSynchronizationConstraint9[A, B, C, D, E, F, G, H, I](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], events9: Events[I], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8), events9))
        
    def eventList9:= 
        if (defaultTime(events9) >= timeNow) then
            List.prepend(9, List.empty[Int])
        else
            List.empty[Int]
    
    def eventList8:= 
        if (defaultTime(events8) >= timeNow) then
            List.prepend(8, eventList9)
        else
            eventList9
     
    def eventList7:= 
        if (defaultTime(events7) >= timeNow) then
            List.prepend(7, eventList8)
        else
            eventList8
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, eventList7)
        else
            eventList7
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 9, tolerance)
}

def StrongSynchronizationConstraint10[A, B, C, D, E, F, G, H, I, J](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], events9: Events[I], events10: Events[J], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8), events9), events10))
    
    def eventList10:= 
        if (defaultTime(events10) >= timeNow) then
            List.prepend(10, List.empty[Int])
        else
            List.empty[Int]    
    
    def eventList9:= 
        if (defaultTime(events9) >= timeNow) then
            List.prepend(9, eventList10)
        else
            eventList10
    
    def eventList8:= 
        if (defaultTime(events8) >= timeNow) then
            List.prepend(8, eventList9)
        else
            eventList9
     
    def eventList7:= 
        if (defaultTime(events7) >= timeNow) then
            List.prepend(7, eventList8)
        else
            eventList8
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, eventList7)
        else
            eventList7
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 10, tolerance)
}