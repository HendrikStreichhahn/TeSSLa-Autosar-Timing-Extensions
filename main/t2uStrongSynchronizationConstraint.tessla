include "t2uHelpFunctions.tessla"

# State information for currently active snchronization clusters
#   xTime: startTime of the cluster (timestamp of first event in this cluster)
#   fulfilledStreams.key:   Indices of all streams
#   fulfilledStreams.value: event in this stream for this cluster?
type synchronizationCluster = {xTime: Int, fulfilledStreams: Map[Int, Bool]}

def StrongSynchronizationConstraint(eventIndices: Events[List[Int]], streamCount: Int, tolerance: Int): Events[fourValuedBoolean]:= {

    def SynchronizationCluster(aTime: Int, aFulfilledStreams: Map[Int, Bool]): synchronizationCluster :=
        {xTime = aTime, fulfilledStreams = aFulfilledStreams}
        
    def buildSynchronizationCluster(time: Int, streamCount: Int): synchronizationCluster :=
        {xTime = time, fulfilledStreams = buildMap(streamCount, false)}

    #checks if a cluster exists, where the event would fit
    def existsMatchingCluster(
            activeClusters: List[synchronizationCluster],   # List of actice clusters
            eventStreamIndex: Int): Bool:=                        # the index of the stream, where the event has occurred
        # list empty-> no matching cluster found
        if (List.size(activeClusters) == 0) then
            false
        else
            # var in map is true-> stream has already event in stream
            if (Map.get(List.head(activeClusters).fulfilledStreams, eventStreamIndex)) then
                existsMatchingCluster(List.tail(activeClusters), eventStreamIndex)
            # var in map is false-> event does fit in this cluster
            else
                true

    #checks, if all streams had an event in this cluster
    def clusterFulfilled(fulfilledStreams: Map[Int, Bool], keys: List[Int]): Bool :=
        # list is empty
        if (Map.size(fulfilledStreams) == 0 || List.size(keys) == 0) then
            true
        else
            # now checked stream is fulfilled
            if Map.get(fulfilledStreams, List.head(keys)) then
                # all following streams are fulfilled
                clusterFulfilled(fulfilledStreams, List.tail(keys))
            else
                false
    #removes all fulfilled clusters from the list
    def removeFulfilled(activeClusters: List[synchronizationCluster]) : List[synchronizationCluster] :=
        if (List.size(activeClusters) == 0) then
            activeClusters
        else
            if clusterFulfilled(List.head(activeClusters).fulfilledStreams,
                    Map.keys(List.head(activeClusters).fulfilledStreams)) then
                removeFulfilled(List.tail(activeClusters))
            else
                List.prepend(List.head(activeClusters), removeFulfilled(List.tail(activeClusters)))
    #updates the synchronization clusters by the given event
    def addEventToClusterList(activeClusters: List[synchronizationCluster], eventStreamIndex: Int):
            List[synchronizationCluster]:= 
        # new event doesn't fit in head of list-> check next one
        if Map.get(List.head(activeClusters).fulfilledStreams, eventStreamIndex) then
            List.prepend(List.head(activeClusters),
                addEventToClusterList(List.tail(activeClusters), eventStreamIndex))
        else
            #set event to fulfilled
            List.prepend(SynchronizationCluster(List.head(activeClusters).xTime, 
                        Map.add(List.head(activeClusters).fulfilledStreams, eventStreamIndex, true)),
                List.tail(activeClusters))
                
    def addEventsToClusters(activeClusters: List[synchronizationCluster], eventIndices: List[Int], time: Int, streamCount: Int) : List[synchronizationCluster]:=
        if (List.size(eventIndices) == 0) then
            activeClusters
        else
            # recursive call-> do for all events in list
            addEventsToClusters(
                # remove clusters, that don't take more events
                    addEventToClusterList(#List.empty[synchronizationCluster],
                        if (existsMatchingCluster(activeClusters, List.head(eventIndices))) then
                            activeClusters
                        else
                            List.append(activeClusters, buildSynchronizationCluster(time, streamCount)),
                    List.head(eventIndices)), 
                List.tail(eventIndices), time, streamCount)
    
    # timestamps, in which the evaluation occurs
    def evaluateTimes: Events[Int] := time(mergeUnit(eventIndices,
        safeDelay(if (List.size(activeClusters) != 0) then
                     List.head(activeClusters).xTime+ tolerance - time(eventIndices)+1
                 else
                    infty, eventIndices)))
                    
    #active clusters with new events
    def activeClustersNewEvent : Events[List[synchronizationCluster]] :=
        slift4(last(activeClusters, eventIndices), eventIndices, evaluateTimes, streamCount, addEventsToClusters)
    # active clusters after removing of full clusters
    def activeClusters: Events[List[synchronizationCluster]] := merge(
        slift1(activeClustersNewEvent, removeFulfilled), 
        List.empty[synchronizationCluster])
    
    stillFulfillabe(
        # no unfinished clusters-> currently true
        if (List.size(activeClusters) == 0) then
            {value= true, final= false}
        else
            # unfinished clusters are not too old-> currently false
            if List.head(activeClusters).xTime + tolerance >= evaluateTimes then
                {value= false, final= false}
            else
                {value= false, final= true})
}

def StrongSynchronizationConstraint2[A, B](events1: Events[A], events2: Events[B], tolerance: Int):
        Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(events1, events2))
    
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, List.empty[Int])
        else
            List.empty[Int]
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList2, 2, tolerance)
}

def StrongSynchronizationConstraint3[A, B, C](events1: Events[A], events2: Events[B], events3: Events[C], tolerance: Int):
        Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(events1, events2), events3))
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, List.empty[Int])
        else
            List.empty[Int]
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 3, tolerance)
}

def StrongSynchronizationConstraint4[A, B, C, D](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(events1, events2), events3), events4))
    
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, List.empty[Int])
        else
            List.empty[Int]
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 4, tolerance)
}

def StrongSynchronizationConstraint5[A, B, C, D, E](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5))
     
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, List.empty[Int])
        else
            List.empty[Int]
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 5, tolerance)
}

def StrongSynchronizationConstraint6[A, B, C, D, E, F](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6))
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, List.empty[Int])
        else
            List.empty[Int]
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 6, tolerance)
}


def StrongSynchronizationConstraint7[A, B, C, D, E, F, G](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7))

    def eventList7:= 
        if (defaultTime(events7) >= timeNow) then
            List.prepend(7, List.empty[Int])
        else
            List.empty[Int]
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, eventList7)
        else
            eventList7
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 7, tolerance)
}

def StrongSynchronizationConstraint8[A, B, C, D, E, F, G, H](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8))
     
    def eventList8:= 
        if (defaultTime(events8) >= timeNow) then
            List.prepend(8, List.empty[Int])
        else
            List.empty[Int]
     
    def eventList7:= 
        if (defaultTime(events7) >= timeNow) then
            List.prepend(7, eventList8)
        else
            eventList8
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, eventList7)
        else
            eventList7
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 8, tolerance)
}

def StrongSynchronizationConstraint9[A, B, C, D, E, F, G, H, I](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], events9: Events[I], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8), events9))
        
    def eventList9:= 
        if (defaultTime(events9) >= timeNow) then
            List.prepend(9, List.empty[Int])
        else
            List.empty[Int]
    
    def eventList8:= 
        if (defaultTime(events8) >= timeNow) then
            List.prepend(8, eventList9)
        else
            eventList9
     
    def eventList7:= 
        if (defaultTime(events7) >= timeNow) then
            List.prepend(7, eventList8)
        else
            eventList8
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, eventList7)
        else
            eventList7
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 9, tolerance)
}

def StrongSynchronizationConstraint10[A, B, C, D, E, F, G, H, I, J](events1: Events[A], events2: Events[B], events3: Events[C], events4: Events[D],
        events5: Events[E], events6: Events[F], events7: Events[G], events8: Events[H], events9: Events[I], events10: Events[J], tolerance: Int): Events[fourValuedBoolean]:={
    def timeNow: Events[Int] := time(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(mergeUnit(
        events1, events2), events3), events4), events5), events6), events7), events8), events9), events10))
    
    def eventList10:= 
        if (defaultTime(events10) >= timeNow) then
            List.prepend(10, List.empty[Int])
        else
            List.empty[Int]    
    
    def eventList9:= 
        if (defaultTime(events9) >= timeNow) then
            List.prepend(9, eventList10)
        else
            eventList10
    
    def eventList8:= 
        if (defaultTime(events8) >= timeNow) then
            List.prepend(8, eventList9)
        else
            eventList9
     
    def eventList7:= 
        if (defaultTime(events7) >= timeNow) then
            List.prepend(7, eventList8)
        else
            eventList8
        
    def eventList6:= 
        if (defaultTime(events6) >= timeNow) then
            List.prepend(6, eventList7)
        else
            eventList7
    
    def eventList5:= 
        if (defaultTime(events5) >= timeNow) then
            List.prepend(5, eventList6)
        else
            eventList6
     
    def eventList4:= 
        if (defaultTime(events4) >= timeNow) then
            List.prepend(4, eventList5)
        else
            eventList5
    
    def eventList3:= 
        if (defaultTime(events3) >= timeNow) then
            List.prepend(3, eventList4)
        else
            eventList4
        
    def eventList2:= 
        if (defaultTime(events2) >= timeNow) then
            List.prepend(2, eventList3)
        else
            eventList3
            
    def eventList:= 
        if (defaultTime(events1) >= timeNow) then
            List.prepend(1, eventList2)
        else
            eventList2

    StrongSynchronizationConstraint(eventList, 10, tolerance)
}