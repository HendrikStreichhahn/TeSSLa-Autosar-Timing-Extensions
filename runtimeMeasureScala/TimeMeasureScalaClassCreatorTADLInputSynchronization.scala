import java.io.FileWriter
import java.io.IOException

class TimeMeasureScalaClassCreatorTADLInputSynchronization extends TimeMeasureScalaClassCreator{
	
	def generateEntireObject(scalaFilePath: String, scalaObjectName: String, resultFilePath: String, repetitionCount: Int,
			eventCount: Int, tolerance: Int, locStreamCount: Int, maxEventsPerClusterPerStream: Int, minClusterDistance: Int,
			maxClusterDistance: Int,  printInputEvents: Boolean): Boolean= {
		var constraintCreator = new TimeMeasureScalaClassCreatorTADLInputSynchronization
		try {
			var fileWriter = new FileWriter(scalaFilePath)
			fileWriter.write("//AUTOGENERATED FILE! CHANGES WILL BE OVERWRITTEN\n")
			fileWriter.write("import java.io._\n")
			fileWriter.write("object " + scalaObjectName + "{\n")
			constraintCreator.generateMainMethod(fileWriter, 1, repetitionCount, resultFilePath)
			fileWriter.write("\n")
			constraintCreator.generateMemberVariableListGeneral(fileWriter, 1, eventCount)
			fileWriter.write("\n")
			constraintCreator.generateMemberVariableListExtended(fileWriter, 1, tolerance, locStreamCount,
				maxEventsPerClusterPerStream, minClusterDistance, maxClusterDistance)
			fileWriter.write("\n")
			constraintCreator.generateMeasureConstraint(fileWriter, 1, printInputEvents, locStreamCount)
			fileWriter.write("\n")
			constraintCreator.generateMeasureMultiple(fileWriter, 1)
			fileWriter.write("\n")
			constraintCreator.generateStoreResultsToFile(fileWriter, 1)
			fileWriter.write("\n")
			constraintCreator.generateAverage(fileWriter, 1)
			fileWriter.write("\n")
			constraintCreator.generateOutputFuncValue(fileWriter, 1, printInputEvents)
			fileWriter.write("\n")
			constraintCreator.generateOutputFuncFinal(fileWriter, 1, printInputEvents)
			fileWriter.write("\n")
			constraintCreator.generateGenerateTrace(fileWriter, 1, repetitionCount, resultFilePath)
			fileWriter.write("\n")
			fileWriter.write("}\n")
			fileWriter.flush()
			fileWriter.close()
		} catch {
			case e: IOException => return false
		}
		return true
	}

	protected def generateMemberVariableListExtended(writer: FileWriter, prevTabCount: Int, tolerance: Int, streamCount: Int,
			maxEventsPerClusterPerStream: Int, minClusterDistance: Int, maxClusterDistance: Int) : Unit = {
		writer.write(tabs(prevTabCount) + "var tolerance: Int = " + tolerance + "\n")
		writer.write(tabs(prevTabCount) + "var streamCount : Int = " + streamCount + "\n")
		writer.write(tabs(prevTabCount) + "var maxEventsPerClusterPerStream : Int = " + maxEventsPerClusterPerStream + "\n")
		writer.write(tabs(prevTabCount) + "var minClusterDistance : Int = " + minClusterDistance + "\n")
		writer.write(tabs(prevTabCount) + "var maxClusterDistance : Int = " + maxClusterDistance + "\n")
		writer.write(tabs(prevTabCount) + "var traceSet : InputSynchronizationConstraintGenerator = null" + "\n")
	}
	
	protected def generateGenerateTrace(writer: FileWriter, prevTabCount: Int, repetitionCount: Int, resultFilePath: String) : Unit = {
		writer.write(tabs(prevTabCount) + "def generateTrace(): Boolean = {" + "\n")
		writer.write(tabs(prevTabCount+1) + "tesslaMonitorInstance = new TesslaMonitor()" + "\n")
		writer.write(tabs(prevTabCount+1) + "traceSet = new InputSynchronizationConstraintGenerator(streamCount)" + "\n")
		writer.write(tabs(prevTabCount+1) + "var res: Boolean = traceSet.generateTestTrace(eventCount, tolerance, minClusterDistance)" + "\n")
		writer.write(tabs(prevTabCount+1) + "if (res) {" + "\n")
		writer.write(tabs(prevTabCount+2) + "traceSet.initOutput();" + "\n")
		writer.write(tabs(prevTabCount+1) + "}" + "\n")
		writer.write(tabs(prevTabCount+1) + "res" + "\n")
		writer.write(tabs(prevTabCount) + "}" + "\n")
	}
	
	protected def generateMeasureConstraintWriteEvents(writer: FileWriter, prevTabCount: Int) : Unit = {
		generateMeasureConstraintWriteEvents(writer, prevTabCount, -1)
	}
	
	protected def generateMeasureConstraintWriteEvents(writer: FileWriter, prevTabCount: Int, locStreamCount: Int) : Unit = {
		writer.write(tabs(prevTabCount) + "for (i <- 0 to currentEvents.length-1){" + "\n")
		writer.write(tabs(prevTabCount+1) + "if (currentEvents(i).getOwnerStream().getName().equals(\"response \" ))" + "\n")
		writer.write(tabs(prevTabCount+2) + "tesslaMonitorInstance.set_var_response(currentEvents(i).getColor(), currentEvents(i).getTimeStamp())" + "\n")
		for (i <- 0 to locStreamCount-1){
			writer.write(tabs(prevTabCount+1) + "if (currentEvents(i).getOwnerStream().getName().equals(\"stimulus " + (i+1) + "\" ))" + "\n")
			writer.write(tabs(prevTabCount+2) + "tesslaMonitorInstance.set_var_stimulus" + (i+1) + "(currentEvents(i).getColor(), currentEvents(i).getTimeStamp())" + "\n")
		}
		//writer.write(tabs(prevTabCount+1) + "if (currentEvents(i).getOwnerStream().getName().equals(\"event\" ))" + "\n")
		//writer.write(tabs(prevTabCount+2) + "tesslaMonitorInstance.set_var_event(currentEvents(i).getColor(), currentEvents(i).getTimeStamp())" + "\n")
		//writer.write(tabs(prevTabCount+1) + "eventCounter = eventCounter+1" + "\n")
		writer.write(tabs(prevTabCount) + "}" + "\n")
	}
	
	protected def generateMeasureConstraint(writer: FileWriter, prevTabCount: Int, printInputEvents: Boolean, locStreamCount: Int) : Unit = {
		writer.write(tabs(prevTabCount) + "def measureConstraint() : (Long, Long, Long) = {" + "\n")
		writer.write(tabs(prevTabCount+1) + "var min = Long.MaxValue" + "\n")
		writer.write(tabs(prevTabCount+1) + "var max = Long.MinValue" + "\n")
		writer.write(tabs(prevTabCount+1) + "var avg = 0L" + "\n")
		writer.write(tabs(prevTabCount+1) + "var eventCounter = 0" + "\n")
		
		
		writer.write(tabs(prevTabCount+1) + "tesslaMonitorInstance = new TesslaMonitor()" + "\n")
		writer.write(tabs(prevTabCount+1) + "tesslaMonitorInstance.out_final = outputFuncFinal" + "\n")
		writer.write(tabs(prevTabCount+1) + "tesslaMonitorInstance.out_value = outputFuncValue" + "\n")
		writer.write(tabs(prevTabCount+1) + "var currentEvents: Array[Event] = traceSet.getNextTimestampsEvents();" + "\n")
		writer.write(tabs(prevTabCount+1) + "var ctr = 0" + "\n")
		writer.write(tabs(prevTabCount+1) + "while (currentEvents.length != 0 && !(outputFinal && ! outputValue)) {" + "\n")
		generateMeasureConstraintWriteEvents(writer, prevTabCount+2, locStreamCount)
		writer.write(tabs(prevTabCount+1) + "eventCounter = eventCounter+1" + "\n")
		writer.write(tabs(prevTabCount+2) + "var time1= System.nanoTime()" + "\n")
		writer.write(tabs(prevTabCount+2) + "tesslaMonitorInstance.flush();" + "\n")
		writer.write(tabs(prevTabCount+2) + "var time2= System.nanoTime" + "\n")
		
		if (printInputEvents)
			generateMeasureConstraintDebugOutput(writer, prevTabCount+2)
		
		writer.write(tabs(prevTabCount+2) + "if (outputFinal && ! outputValue){\n")
		writer.write(tabs(prevTabCount+3) + "min = -1L\n")
		writer.write(tabs(prevTabCount+3) + "max = -1L\n")
		writer.write(tabs(prevTabCount+3) + "avg = 0L\n")
		writer.write(tabs(prevTabCount+3) + "println(\"Error state reached MeasureConstraint()\")\n")
		//writer.write(tabs(prevTabCount+3) + "loop.break\n")
		writer.write(tabs(prevTabCount+2) + "}\n")
		
		
		writer.write(tabs(prevTabCount+2) + "var timeEvent = time2-time1" + "\n")
		writer.write(tabs(prevTabCount+2) + "min = if (timeEvent < min) timeEvent else min" + "\n")
		writer.write(tabs(prevTabCount+2) + "max = if (timeEvent > max) timeEvent else max" + "\n")
		writer.write(tabs(prevTabCount+2) + "avg += timeEvent" + "\n")
		writer.write(tabs(prevTabCount+2) + "currentEvents = traceSet.getNextTimestampsEvents();" + "\n")
		writer.write(tabs(prevTabCount+2) + "ctr = ctr+1" + "\n")
		writer.write(tabs(prevTabCount+1) + "}" + "\n")
		writer.write(tabs(prevTabCount+1) + "traceSet.resetOutputCounter()" + "\n")
		writer.write(tabs(prevTabCount+1) + "if (eventCounter == 0)\n")
		writer.write(tabs(prevTabCount+2) + "(0L, 0L, 0L)\n")
		writer.write(tabs(prevTabCount+1) + "else\n")
		writer.write(tabs(prevTabCount+2) + "(min, max, avg / eventCounter)" + "\n")
		writer.write(tabs(prevTabCount) + "}" + "\n")
	}
}